<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Redis主从架构数据同步原理 | 熟悉路线站点</title><meta name="description" content="Redis主从架构数据同步原理主从架构如何保证数据一致性？读写分离。写操作只在主库，读执行操作主库和从库都可以执行。如果写操作可以在主库和从库进行，为了保持数据一致性就需要在Redis进行加锁，这样会减慢Redis的速度 如何搭建主从复制架构？（三种方式）1、从服务器的配置文件 1replicaof &lt;masterip&gt; &lt;masterport&gt; 2、启动 redis-se"><meta property="og:type" content="article"><meta property="og:title" content="Redis主从架构数据同步原理"><meta property="og:url" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="熟悉路线站点"><meta property="og:description" content="Redis主从架构数据同步原理主从架构如何保证数据一致性？读写分离。写操作只在主库，读执行操作主库和从库都可以执行。如果写操作可以在主库和从库进行，为了保持数据一致性就需要在Redis进行加锁，这样会减慢Redis的速度 如何搭建主从复制架构？（三种方式）1、从服务器的配置文件 1replicaof &lt;masterip&gt; &lt;masterport&gt; 2、启动 redis-se"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/Redis主从架构第一次全量复制过程图.png"><meta property="og:image" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/增量复制repl_backlog_buffer.png"><meta property="og:image" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/Redis长连接过程.png"><meta property="og:image" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/replication%20buffer和repl_backlog.png"><meta property="article:published_time" content="2021-04-25T15:11:33.000Z"><meta property="article:modified_time" content="2021-05-11T07:46:58.341Z"><meta property="article:author" content="duanjiaojiao"><meta property="article:tag" content="redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/Redis主从架构第一次全量复制过程图.png"><link rel="canonical" href="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/index.html"><link rel="alternate" href="/atom.xml" title="熟悉路线站点" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.2.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/duanjiaojiao316" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">熟悉路线站点</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Developer &amp; Designer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">书单</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E5%91%BD%E4%BB%A4/" rel="tag">mysql命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%96%87/" rel="tag">回文</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">算法 BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">BFS（广度优先搜索）</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size:13px">Java基础</a> <a href="/tags/Kafka/" style="font-size:13px">Kafka</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/mybatis/" style="font-size:13px">mybatis</a> <a href="/tags/mysql%E5%91%BD%E4%BB%A4/" style="font-size:13px">mysql命令</a> <a href="/tags/redis/" style="font-size:14px">redis</a> <a href="/tags/%E5%9B%9E%E6%96%87/" style="font-size:13px">回文</a> <a href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">算法 BFS（广度优先搜索）</a> <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" style="font-size:13px">阅读笔记</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/04/26/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="title">redis分布式锁</a></p><p class="item-date"><time datetime="2021-04-26T13:10:30.000Z" itemprop="datePublished">2021-04-26</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p><p class="item-title"><a href="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" class="title">Redis主从架构数据同步原理</a></p><p class="item-date"><time datetime="2021-04-25T15:11:33.000Z" itemprop="datePublished">2021-04-25</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a></p><p class="item-title"><a href="/2021/03/11/%E6%9C%89%E5%85%B3%E5%9B%9E%E6%96%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/" class="title">有关回文的编程题总结</a></p><p class="item-date"><time datetime="2021-03-11T13:09:05.000Z" itemprop="datePublished">2021-03-11</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/03/09/%E5%85%B3%E4%BA%8EYARN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="title">关于YARN——基础知识</a></p><p class="item-date"><time datetime="2021-03-09T13:56:09.000Z" itemprop="datePublished">2021-03-09</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/03/09/VAEs%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/" class="title">VAEs变分自编码器</a></p><p class="item-date"><time datetime="2021-03-09T02:30:11.000Z" itemprop="datePublished">2021-03-09</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-Redis主从架构数据同步原理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Redis主从架构数据同步原理</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" class="article-date"><time datetime="2021-04-25T15:11:33.000Z" itemprop="datePublished">2021-04-25</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/redis/" rel="tag">redis</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 3.1k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 11(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="Redis主从架构数据同步原理"><a href="#Redis主从架构数据同步原理" class="headerlink" title="Redis主从架构数据同步原理"></a><code>Redis</code>主从架构数据同步原理</h1><h2 id="主从架构如何保证数据一致性？"><a href="#主从架构如何保证数据一致性？" class="headerlink" title="主从架构如何保证数据一致性？"></a>主从架构如何保证数据一致性？</h2><p>读写分离。写操作只在主库，读执行操作主库和从库都可以执行。如果写操作可以在主库和从库进行，为了保持数据一致性就需要在<code>Redis</code>进行加锁，这样会减慢<code>Redis</code>的速度</p><h2 id="如何搭建主从复制架构？（三种方式）"><a href="#如何搭建主从复制架构？（三种方式）" class="headerlink" title="如何搭建主从复制架构？（三种方式）"></a>如何搭建主从复制架构？（三种方式）</h2><p>1、从服务器的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>2、启动</p><p><code>redis-server</code>启动命令<code>--replicaof &lt;masterip&gt; &lt;masterport&gt;</code></p><p>3、客户端命令</p><p>启动多个 <code>Redis</code>实例后，直接通过客户端执行命令：<code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code>，则该 <code>Redis</code> 实例成为从节点。</p><h2 id="主从第一次全量复制"><a href="#主从第一次全量复制" class="headerlink" title="主从第一次全量复制"></a>主从第一次全量复制</h2><p>三个阶段：建立连接、主库同步数据给从库、发送新的写命令给从库。</p><p><img src="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/Redis主从架构第一次全量复制过程图.png" alt="Redis主从架构第一次全量复制过程图"></p><h3 id="第一阶段建立连接"><a href="#第一阶段建立连接" class="headerlink" title="第一阶段建立连接"></a>第一阶段建立连接</h3><p><strong>从库会和主库建立连接，从库执行<code>replicaof</code> 并发送<code>psync</code> 命令并告诉主库即将进行同步，主库确认回复后，主从库间就开始同步了</strong>。</p><p>从节点内部维护了两个字段，<code>masterhost</code> 和 <code>masterport</code>，用于存储主节点的 IP 和 port 信息。</p><p>从库执行 <code>replicaof</code> 并发送 <code>psync</code> 命令，表示要执行数据同步，主库收到命令后根据参数启动复制。命令包含了<strong>主库的 <code>runID</code></strong> 和 <strong>复制进度 <code>offset</code></strong> 两个参数。</p><ul><li><strong><code>runID</code></strong>：每个 <code>Redis</code> 实例启动都会自动生成一个 唯一标识 ID，第一次主从复制，还不知道主库 <code>runID</code>，参数设置为 「?」。</li><li><strong><code>offset</code></strong>：第一次复制设置为 -1，表示第一次复制，记录复制进度偏移量。</li></ul><p>主库收到<code>psync</code>命令后，会用 <strong><code>FULLRESYNC</code> 响应命令带上两个参数：主库 <code>runID</code> 和主库目前的复制进度<code>offset</code>，返回给从库</strong>。从库收到响应后，会记录下这两个参数。</p><p><strong><code>FULLRESYNC</code> 响应表示第一次复制采用的全量复制</strong>，也就是说，主库会把当前所有的数据都复制给从库。</p><h3 id="第二阶段发送同步数据"><a href="#第二阶段发送同步数据" class="headerlink" title="第二阶段发送同步数据"></a>第二阶段发送同步数据</h3><p>master 执行 <code>bgsave</code>命令生成 RDB 文件，并将文件发送给从库，同时<strong>主库</strong>为每一个 slave 开辟一块 <strong>replication buffer</strong> 缓冲区记录从生成 RDB 文件开始收到的所有写命令。</p><p>从库收到 RDB 文件后保存到磁盘，并清空当前数据库的数据，再加载 RDB 文件数据到内存中。</p><h4 id="为什么清空从库的数据？"><a href="#为什么清空从库的数据？" class="headerlink" title="为什么清空从库的数据？"></a>为什么清空从库的数据？</h4><p>因为从库在通过 <code>replcaof</code>命令开始和主库同步前可能保存了其他数据，防止主从数据之间的影响。</p><h3 id="第三阶段发送新命令到从库"><a href="#第三阶段发送新命令到从库" class="headerlink" title="第三阶段发送新命令到从库"></a>第三阶段发送新命令到从库</h3><h4 id="replication-buffer-缓冲区存放数据"><a href="#replication-buffer-缓冲区存放数据" class="headerlink" title="replication buffer 缓冲区存放数据"></a><strong>replication buffer</strong> 缓冲区存放数据</h4><blockquote><p>1）<code>master</code> 执行 <code>bgsave</code>产生 RDB 的期间的写操作；</p><p>2）<code>master</code> 发送<code>rdb</code> 到 <code>slave</code> 网络传输期间的写操作；</p><p>3）<code>slave load rdb</code> 文件把数据恢复到内存的期间的写操作。</p></blockquote><h4 id="replication-buffer-太小会引发的问题？"><a href="#replication-buffer-太小会引发的问题？" class="headerlink" title="replication buffer 太小会引发的问题？"></a>replication buffer 太小会引发的问题？</h4><p>replication buffer 由 client-output-buffer-limit slave 设置，当这个值太小会导致<strong>主从复制连接断开</strong>。</p><p>1）当 master-slave 复制连接断开，master 会释放连接相关的数据。replication buffer 中的数据也就丢失了，此时主从之间重新开始复制过程。</p><p>2）还有个更严重的问题，<strong>主从复制连接断开，导致主从上出现重新执行 <code>bgsave</code> 和 <code>rdb</code> 重传操作无限循环。</strong></p><p>当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；</p><p>这种情况可能引起全量复制 -&gt; replication buffer 溢出导致连接中断 -&gt; 重连 -&gt; 全量复制 -&gt; replication buffer 缓冲区溢出导致连接中断……的循环。</p><p>具体详情：<code>[top redis headaches for devops – replication buffer]</code> 因而推荐把 replication buffer 的 hard/soft limit 设置成 512M。</p><h3 id="主从库复制为何不使用-AOF-呢？相比-RDB-来说，丢失的数据更少。原因如下："><a href="#主从库复制为何不使用-AOF-呢？相比-RDB-来说，丢失的数据更少。原因如下：" class="headerlink" title="主从库复制为何不使用 AOF 呢？相比 RDB 来说，丢失的数据更少。原因如下："></a>主从库复制为何不使用 AOF 呢？相比 RDB 来说，丢失的数据更少。原因如下：</h3><ol><li>RDB 文件是二进制文件，网络传输 RDB 和写入磁盘的 IO 效率都要比 AOF 高。</li><li>从库进行数据恢复的时候，RDB 的恢复效率也要高于 AOF。</li></ol><h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><p>在 <code>Redis 2.8</code> 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p><p>从 <code>Redis 2.8</code>开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p><p>增量复制：<strong>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效</strong>。</p><h3 id="repl-backlog-buffer-缓冲区"><a href="#repl-backlog-buffer-缓冲区" class="headerlink" title="repl_backlog_buffer 缓冲区"></a><code>repl_backlog_buffer</code> 缓冲区</h3><p>断开重连增量复制的实现奥秘就是 <code>repl_backlog_buffer</code> 缓冲区，不管在什么时候 master 都会将写指令操作记录在 <code>repl_backlog_buffer</code> 中，因为内存有限，<code>repl_backlog_buffer</code> 是一个定长的环形数组，<strong>如果数组内容满了，就会从头开始覆盖前面的内容</strong>。</p><p>master 使用 <code>master_repl_offset</code>记录自己写到的位置偏移量，slave 则使用<code>slave_repl_offset</code>记录已经读取到的偏移量。</p><p>master 收到写操作，偏移量则会增加。从库持续执行同步的写指令后，在 <code>repl_backlog_buffer</code> 的已复制的偏移量<code>slave_repl_offset</code> 也在不断增加。</p><p>正常情况下，这两个偏移量基本相等。在网络断连阶段，主库可能会收到新的写操作命令，所以 <code>master_repl_offset</code>会大于 <code>slave_repl_offset</code>。</p><p><img src="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/增量复制repl_backlog_buffer.png" alt="增量复制repl_backlog_buffer"></p><h3 id="repl-backlog-buffer-太小的话从库还没读取到就被-Master-的新写操作覆盖了咋办？"><a href="#repl-backlog-buffer-太小的话从库还没读取到就被-Master-的新写操作覆盖了咋办？" class="headerlink" title="repl_backlog_buffer 太小的话从库还没读取到就被 Master 的新写操作覆盖了咋办？"></a><code>repl_backlog_buffer</code> 太小的话从库还没读取到就被 Master 的新写操作覆盖了咋办？</h3><p>一旦被覆盖就会执行全量复制。我们可以调整 <code>repl_backlog_size</code> 这个参数用于控制缓冲区大小。计算公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl_backlog_buffer = second * write_size_per_second</span><br></pre></td></tr></table></figure><ol><li><strong><code>second</code></strong>：从服务器断开重连主服务器所需的平均时间；</li><li><strong><code>write_size_per_second</code></strong>：master 平均每秒产生的命令数据量大小（写命令和数据大小总和）；</li></ol><p>例如，如果主服务器平均每秒产生 1 MB 的写数据，而从服务器断线之后平均要 5 秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于 5 MB。</p><p>为了安全起见，可以将复制积压缓冲区的大小设为<code>2 * second * write_size_per_second</code>，这样可以保证绝大部分断线情况都能用部分重同步来处理。</p><h3 id="基于长连接的命令传播"><a href="#基于长连接的命令传播" class="headerlink" title="基于长连接的命令传播"></a>基于长连接的命令传播</h3><p>当主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，使用长连接的目的就是避免频繁建立连接导致的开销。</p><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：<strong>PING 和 REPLCONF ACK。</strong></p><p><strong>主-&gt;从：PING</strong></p><p>每隔指定的时间，<strong>主节点会向从节点发送 PING 命令</strong>，这个 PING 命令的作用，主要是为了让从节点进行超时判断。</p><p><strong>从-&gt;主：REPLCONF ACK</strong></p><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure><p>其中 replication_offset 是从服务器当前的复制偏移量。发送 REPLCONF ACK 命令对于主从服务器有三个作用：</p><ol><li>检测主从服务器的网络连接状态。</li><li>辅助实现 min-slaves 选项。</li><li>检测命令丢失, 从节点发送了自身的 slave_replication_offset，主节点会用自己的 master_replication_offset 对比，如果从节点数据缺失，主节点会从 <code>repl_backlog_buffer</code>缓冲区中找到并推送缺失的数据。<strong>注意，offset 和 <code>repl_backlog_buffer</code> 缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></li></ol><p><img src="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/Redis长连接过程.png" alt="Redis长连接过程"></p><ol><li><p>从节点根据当前状态，发送 <code>psync</code>命令给 master：</p></li><li><ul><li>如果从节点从未执行过 <code>replicaof</code> ，则从节点发送 <code>psync ? -1</code>，向主节点发送全量复制请求；</li><li>如果从节点之前执行过 <code>replicaof</code> 则发送 <code>psync &lt;runID&gt; &lt;offset&gt;</code>,<code>runID</code>是上次复制保存的主节点 <code>runID</code>，offset 是上次复制截至时从节点保存的复制偏移量。</li></ul></li><li><p>主节点根据接受到的<code>psync</code>命令和当前服务器状态，决定执行全量复制还是部分复制：</p></li><li><ul><li><code>runID</code> 与从节点发送的<code>runID</code> 相同，且从节点发送的 <code>slave_repl_offset</code>之后的数据在 <code>repl_backlog_buffer</code>缓冲区中都存在，则回复 <code>CONTINUE</code>，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li><li><code>runID</code> 与从节点发送的<code>runID</code>不同，或者从节点发送的 <code>slave_repl_offset</code> 之后的数据已不在主节点的 <code>repl_backlog_buffer</code>缓冲区中 (在队列中被挤出了)，则回复从节点 <code>FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，表示要进行全量复制，其中<code>runID</code> 表示主节点当前的 <code>runID</code>，offset 表示主节点当前的 offset，从节点保存这两个值，以备使用。</li></ul></li></ol><p>一个从库如果和主库断连时间过长，造成它在主库 <code>repl_backlog_buffer</code>的 <code>slave_repl_offset</code> 位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。</p><h2 id="replication-buffer-和-repl-backlog"><a href="#replication-buffer-和-repl-backlog" class="headerlink" title="replication buffer 和 repl_backlog"></a><code>replication buffer</code> 和 <code>repl_backlog</code></h2><ol><li>replication buffer 对应于每个 slave，通过 <code>config set client-output-buffer-limit slave</code>设置。</li><li><code>repl_backlog_buffer</code>是一个环形缓冲区，整个 master 进程中只会存在一个，所有的 slave 公用。<code>repl_backlog</code> 的大小通过 <code>repl-backlog-size</code>参数设置，默认大小是 1M，其大小可以根据每秒产生的命令、（master 执行 <code>rdb bgsave</code>） +（ <code>master</code> 发送 <code>rdb</code> 到 slave） + （<code>slave load rdb</code>文件）时间之和来估算积压缓冲区的大小，<code>repl-backlog-size</code> 值不小于这两者的乘积。</li></ol><p>总的来说，<code>replication buffer</code> 是主从库在进行全量复制时，主库上用于和从库连接的客户端的 buffer，而 r<code>epl_backlog_buffer</code> 是为了支持从库增量复制，主库上用于持续保存写操作的一块专用 buffer。</p><p><code>repl_backlog_buffer</code>是一块专用 buffer，在 <code>Redis</code> 服务器启动后，开始一直接收写操作命令，这是所有从库共享的。主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，会把自己的复制进度（<code>slave_repl_offset</code>）发给主库，主库就可以和它独立同步。</p><p><img src="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/replication buffer和repl_backlog.png" alt="replication buffer和repl_backlog"></p><h2 id="主从架构应用问题"><a href="#主从架构应用问题" class="headerlink" title="主从架构应用问题"></a>主从架构应用问题</h2><h3 id="主从复制的场景下，从节点会删除过期数据么？"><a href="#主从复制的场景下，从节点会删除过期数据么？" class="headerlink" title="主从复制的场景下，从节点会删除过期数据么？"></a>主从复制的场景下，从节点会删除过期数据么？</h3><p>为了主从节点的数据一致性，从节点不会主动删除数据。我们知道 <code>Redis</code> 有两种删除策略：</p><ol><li>惰性删除：当客户端查询对应的数据时，<code>Redis</code> 判断该数据是否过期，过期则删除。</li><li>定期删除：<code>Redis</code> 通过定时任务删除过期数据。</li></ol><h3 id="客户端通过从节点读取数据会不会读取到过期数据？"><a href="#客户端通过从节点读取数据会不会读取到过期数据？" class="headerlink" title="客户端通过从节点读取数据会不会读取到过期数据？"></a>客户端通过从节点读取数据会不会读取到过期数据？</h3><p><code>Redis 3.2</code>开始，通过从节点读取数据时，先判断数据是否已过期。如果过期则不返回客户端，并且删除数据。</p><h3 id="单机内存大小限制"><a href="#单机内存大小限制" class="headerlink" title="单机内存大小限制"></a>单机内存大小限制</h3><p>如果<code>Redis</code> 单机内存达到 10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。</p><p>如果数据量过大，全量复制阶段主节点 fork + 保存 RDB 文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入<strong>全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断</strong>……的循环。</p><p>此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用 50% - 65% 的内存，留下 30%-45% 的内存用于执行<code>bgsave</code> 命令和创建复制缓冲区等。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" title="Redis主从架构数据同步原理" target="_blank" rel="external">https://duanjiaojiao316.github.io/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/duanjiaojiao316" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/duanjiaojiao316" target="_blank"><span class="text-dark">熟悉路线站点</span><small class="ml-1x">Developer &amp; Designer</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/04/26/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="redis分布式锁"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2021/03/11/%E6%9C%89%E5%85%B3%E5%9B%9E%E6%96%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/" title="有关回文的编程题总结"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>