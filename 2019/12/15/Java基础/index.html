<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Java 基础 | 熟悉路线站点</title><meta name="description" content="Java 基础1、Java特性继承super关键字的使用super关键字的两种用法：  调用超类的构造函数 访问超类中被子类的某个成员隐藏的成员（同名隐藏）  注意： 调用超类构造函数super()必须是子类构造函数中的第一条语句。  必须在构造器的第一行放置super或者this构造器，否则编译器会自动地放一个空参数的super构造器的，其他的构造器也可以调用super或者this，调用成一个递"><meta property="og:type" content="article"><meta property="og:title" content="Java 基础"><meta property="og:url" content="https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="熟悉路线站点"><meta property="og:description" content="Java 基础1、Java特性继承super关键字的使用super关键字的两种用法：  调用超类的构造函数 访问超类中被子类的某个成员隐藏的成员（同名隐藏）  注意： 调用超类构造函数super()必须是子类构造函数中的第一条语句。  必须在构造器的第一行放置super或者this构造器，否则编译器会自动地放一个空参数的super构造器的，其他的构造器也可以调用super或者this，调用成一个递"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/面试/springbootimages/javacore-io-001.png"><meta property="og:image" content="http://icdn.apigo.cn/blog/javacore-io-002.png"><meta property="og:image" content="http://icdn.apigo.cn/blog/javacore-io-004.png"><meta property="og:image" content="http://icdn.apigo.cn/blog/javacore-io-003.png"><meta property="og:image" content="http://icdn.apigo.cn/blog/javacore-io-005.png"><meta property="article:published_time" content="2019-12-15T12:25:17.000Z"><meta property="article:modified_time" content="2021-04-20T07:44:33.811Z"><meta property="article:author" content="duanjiaojiao"><meta property="article:tag" content="Java基础"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/面试/springbootimages/javacore-io-001.png"><link rel="canonical" href="https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="alternate" href="/atom.xml" title="熟悉路线站点" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.2.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/duanjiaojiao316" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">熟悉路线站点</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Developer &amp; Designer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">书单</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E5%91%BD%E4%BB%A4/" rel="tag">mysql命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%96%87/" rel="tag">回文</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" rel="tag">支持向量机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">算法 BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">BFS（广度优先搜索）</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size:13px">Java基础</a> <a href="/tags/Kafka/" style="font-size:13px">Kafka</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/mybatis/" style="font-size:13px">mybatis</a> <a href="/tags/mysql%E5%91%BD%E4%BB%A4/" style="font-size:13px">mysql命令</a> <a href="/tags/redis/" style="font-size:13px">redis</a> <a href="/tags/%E5%9B%9E%E6%96%87/" style="font-size:13px">回文</a> <a href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" style="font-size:13px">支持向量机</a> <a href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">算法 BFS（广度优先搜索）</a> <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" style="font-size:13px">阅读笔记</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p><p class="item-title"><a href="/2021/03/13/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95/" class="title">拉格朗日乘子法</a></p><p class="item-date"><time datetime="2021-03-13T06:26:33.000Z" itemprop="datePublished">2021-03-13</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a></p><p class="item-title"><a href="/2021/03/11/%E6%9C%89%E5%85%B3%E5%9B%9E%E6%96%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E6%80%BB%E7%BB%93/" class="title">有关回文的编程题总结</a></p><p class="item-date"><time datetime="2021-03-11T13:09:05.000Z" itemprop="datePublished">2021-03-11</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/03/09/%E5%85%B3%E4%BA%8EYARN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="title">关于YARN——基础知识</a></p><p class="item-date"><time datetime="2021-03-09T13:56:09.000Z" itemprop="datePublished">2021-03-09</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/03/09/VAEs%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/" class="title">VAEs变分自编码器</a></p><p class="item-date"><time datetime="2021-03-09T02:30:11.000Z" itemprop="datePublished">2021-03-09</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></p><p class="item-title"><a href="/2021/01/08/%E5%88%9D%E5%A7%8BKafka/" class="title">初始Kafka</a></p><p class="item-date"><time datetime="2021-01-08T13:56:47.000Z" itemprop="datePublished">2021-01-08</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-Java基础" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Java 基础</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2019/12/15/Java%E5%9F%BA%E7%A1%80/" class="article-date"><time datetime="2019-12-15T12:25:17.000Z" itemprop="datePublished">2019-12-15</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Java/">Java</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/12/15/Java%E5%9F%BA%E7%A1%80/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.9k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 46(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1、Java特性"><a href="#1、Java特性" class="headerlink" title="1、Java特性"></a>1、Java特性</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h4><p>super关键字的两种用法：</p><ol><li>调用超类的构造函数</li><li>访问超类中被子类的某个成员隐藏的成员（同名隐藏）</li></ol><p>注意：</p><p>调用超类构造函数<code>super()</code>必须是子类构造函数中的第一条语句。</p><p><code>必须在构造器的第一行放置super或者this构造器，否则编译器会自动地放一个空参数的super构造器的，其他的构造器也可以调用super或者this，调用成一个递归构造链，最后的结果是父类的构造器（可能有多级父类构造器）始终在子类的构造器之前执行，递归的调用父类构造器。无法执行当前的类的构造器。也就不能实例化任何对象，这个类就成为一个无为类。 从另外一面说，子类是从父类继承而来，继承了父类的属性和方法，如果在子类中先不完成父类的成员的初始化，则子类无法使用，因为在java中不允许调用没初始化的成员。在构造器中是顺序执行的，也就是说必须在第一行进行父类的初始化。而super能直接完成这个功能。this()通过调用本类中的其他构造器也能完成这个功能。 因此，this()或者super()必须放在第一行。</code></p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person s = <span class="keyword">new</span> Student(<span class="number">15</span>,<span class="string">&quot;djj&quot;</span>,<span class="number">96</span>);</span><br></pre></td></tr></table></figure><p>但是用过s引用不能查找子类中的变量实现等。</p><p>如果子类覆写父类的一个方法，s调用这个方法，实现是student的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the Student&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person s = <span class="keyword">new</span> Student(<span class="number">15</span>,<span class="string">&quot;djj&quot;</span>,<span class="number">96</span>);</span><br><span class="line">        s.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">    the Student</span><br></pre></td></tr></table></figure><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>向下转型可能会失败，抛出 <code>ClassCastException</code>异常。</p><h4 id="区分继承和组合"><a href="#区分继承和组合" class="headerlink" title="区分继承和组合"></a>区分继承和组合</h4><p>is关系采用继承，但是has关系使用组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p><p>利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="comment">//计算税</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工资</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//国家津贴</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Income income = <span class="keyword">new</span> Income();</span><br><span class="line">        income.income = <span class="number">1000</span>;</span><br><span class="line">        Salary salary = <span class="keyword">new</span> Salary();</span><br><span class="line">        salary.income = <span class="number">6000</span>;</span><br><span class="line">        StateCouncilSpecialAllowance state = <span class="keyword">new</span> StateCouncilSpecialAllowance();</span><br><span class="line">        state.income = <span class="number">5000</span>;</span><br><span class="line">        System.out.println(totalTax(salary, state));</span><br><span class="line">        System.out.println(totalTax(state));</span><br><span class="line">        System.out.println(totalTax(salary));</span><br><span class="line">        System.out.println(totalTax(income, salary));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>：<span class="title">public</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">A *pa = <span class="keyword">new</span> B();</span><br><span class="line">pa-&gt;foo();</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">200.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">200.0</span></span><br><span class="line"><span class="number">300.0</span></span><br></pre></td></tr></table></figure><h2 id="2、包"><a href="#2、包" class="headerlink" title="2、包"></a>2、包</h2><h3 id="2-1包和成员访问"><a href="#2-1包和成员访问" class="headerlink" title="2.1包和成员访问"></a>2.1包和成员访问</h3><table><thead><tr><th></th><th>private</th><th>无访问修饰符</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>在同一个类中是否可见</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>相同的包中的子类</td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td>相同的包中的非子类</td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不同包中的子类</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>不同包中的非子类</td><td>否</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><ul><li>public 可以在任何位置访问</li><li>默认访问级别 子类或者相同包的下的其他类可以访问</li><li>protected 可以在包外访问，但是仅限子类可以访问</li><li>private只能在自己的类中访问</li></ul><h2 id="3、接口"><a href="#3、接口" class="headerlink" title="3、接口"></a>3、接口</h2><h3 id="3-1接口中的变量"><a href="#3-1接口中的变量" class="headerlink" title="3.1接口中的变量"></a>3.1接口中的变量</h3><p>可以使用接口将共享的变量导入到多个类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SharedConstants</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> NO = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Yes = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">这些变量在作用域内会被作为常量。</font></p><h3 id="3-2默认接口方法"><a href="#3-2默认接口方法" class="headerlink" title="3.2默认接口方法"></a>3.2默认接口方法</h3><p>在JDK1.8之前没有默认接口方法，默认方法之前使用关键字default。</p><p>动机：</p><ol><li>给接口添加新的方法，不会破坏之前实现该接口的代码。由于必须实现接口中的所有方法，如果接口加入新的方法，那么实现它的类就必须实现该方法，这样就会破坏现有的代码。</li><li>让新方法的实现具有可选性。有些类可以选择不使用。</li></ol><h3 id="3-3多级继承问题"><a href="#3-3多级继承问题" class="headerlink" title="3.3多级继承问题"></a>3.3多级继承问题</h3><p>一个类实现两个接口，这两个接口提供了相同的方法，这个方法会产生冲突。</p><p>类的实现的优先级高于接口默认方法的优先级。所以可以通过类的实现解决冲突。</p><h3 id="3-4接口的静态方法"><a href="#3-4接口的静态方法" class="headerlink" title="3.4接口的静态方法"></a>3.4接口的静态方法</h3><p>同类的静态方法，无须实现接口，也无须接口的实例，只需要接口名就可以使用接口的默认静态方法。</p><h3 id="3-5私有的接口方法"><a href="#3-5私有的接口方法" class="headerlink" title="3.5私有的接口方法"></a>3.5私有的接口方法</h3><h2 id="4、异常"><a href="#4、异常" class="headerlink" title="4、异常"></a>4、异常</h2><h3 id="4-1链式异常"><a href="#4-1链式异常" class="headerlink" title="4.1链式异常"></a>4.1链式异常</h3><p>链式异常可以为异常关联另一个异常，为了描述造成以第一个异常的原因。</p><p>构造函数关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">       fillInStackTrace();</span><br><span class="line">       detailMessage = message;</span><br><span class="line">       <span class="keyword">this</span>.cause = cause;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">       fillInStackTrace();</span><br><span class="line">       detailMessage = (cause==<span class="keyword">null</span> ? <span class="keyword">null</span> : cause.toString());</span><br><span class="line">       <span class="keyword">this</span>.cause = cause;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>支持链式异常的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cause==<span class="keyword">this</span> ? <span class="keyword">null</span> : cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">initCause</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cause != <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can&#x27;t overwrite cause with &quot;</span> +</span><br><span class="line">                                        Objects.toString(cause, <span class="string">&quot;a null&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (cause == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Self-causation not permitted&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getCause方法返回引起当前异常的异常，没有就返回null。</p><p>对于每个异常对象只能进行一次initCause，如果使用构造函数关联就不能再使用initCause进行设置。通常initCause方法是为了解决之前不支持链式异常的异常类（不包含支持链式异常的构造方法）不能关联异常设置的。</p><h2 id="5、IO-BIO-NIO-AIO"><a href="#5、IO-BIO-NIO-AIO" class="headerlink" title="5、IO (BIO) NIO AIO"></a>5、IO (BIO) NIO AIO</h2><h3 id="5-1-BIO、NIO、AIO的区别"><a href="#5-1-BIO、NIO、AIO的区别" class="headerlink" title="5.1 BIO、NIO、AIO的区别"></a>5.1 BIO、NIO、AIO的区别</h3><ol><li>BIO 就是传统的 <a target="_blank" rel="noopener" href="http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞</strong>的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ol><h3 id="5-2-IO"><a href="#5-2-IO" class="headerlink" title="5.2 IO"></a>5.2 IO</h3><h4 id="传统的-IO-大致可以分为4种类型："><a href="#传统的-IO-大致可以分为4种类型：" class="headerlink" title="传统的 IO 大致可以分为4种类型："></a>传统的 IO 大致可以分为4种类型：</h4><ul><li>InputStream、OutputStream 基于字节操作的 IO</li><li>Writer、Reader 基于字符操作的 IO</li><li>File 基于磁盘操作的 IO</li><li>Socket 基于网络操作的 IO</li></ul><h4 id="InputStream-OutputStream-Writer-Reader"><a href="#InputStream-OutputStream-Writer-Reader" class="headerlink" title="InputStream OutputStream Writer Reader"></a><strong>InputStream OutputStream Writer Reader</strong></h4><p><img src="/2019/12/15/Java%E5%9F%BA%E7%A1%80/面试\springbootimages\javacore-io-001.png" alt="img"> <img src="http://icdn.apigo.cn/blog/javacore-io-002.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\log.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">inputStream.read(bytes);</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">inputStream.close();</span><br><span class="line"></span><br><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\log.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，表示是否追加，true=追加</span></span><br><span class="line">outputStream.write(<span class="string">&quot;你好，老王&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure><p><img src="http://icdn.apigo.cn/blog/javacore-io-004.png" alt="img"></p><p><img src="http://icdn.apigo.cn/blog/javacore-io-003.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\log.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，是否追加文件，true=追加</span></span><br><span class="line">writer.append(<span class="string">&quot;老王，你好&quot;</span>);</span><br><span class="line">writer.close();</span><br><span class="line"></span><br><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\log.txt&quot;</span>);</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">StringBuffer bf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bf.append(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br><span class="line">reader.close();</span><br><span class="line">System.out.println(bf.toString());</span><br></pre></td></tr></table></figure><h4 id="Java-7-引入了Files（java-nio包下）的，大大简化了文件的读写，如下："><a href="#Java-7-引入了Files（java-nio包下）的，大大简化了文件的读写，如下：" class="headerlink" title="Java 7 引入了Files（java.nio包下）的，大大简化了文件的读写，如下："></a>Java 7 引入了Files（java.nio包下）的，大大简化了文件的读写，如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件（追加方式：StandardOpenOption.APPEND）</span></span><br><span class="line">Files.write(Paths.get(filePath), Content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">byte</span>[] data = Files.readAllBytes(Paths.get(filePath));</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多（单）层目录（如果不存在创建，存在不会报错）</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;D://a//b&quot;</span>).mkdirs();</span><br></pre></td></tr></table></figure><p>一个简单的 Socket，服务器端只发给客户端信息，再由客户端打印出来的例子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> port = <span class="number">4343</span>; <span class="comment">//端口号</span></span><br><span class="line"><span class="comment">// Socket 服务器端（简单的发送信息）</span></span><br><span class="line">Thread sThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                Thread sHandlerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> (PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(socket.getOutputStream())) &#123;</span><br><span class="line">                            printWriter.println(<span class="string">&quot;hello world！&quot;</span>);</span><br><span class="line">                            printWriter.flush();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                sHandlerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">sThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Socket 客户端（接收信息并打印）</span></span><br><span class="line"><span class="keyword">try</span> (Socket cSocket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), port)) &#123;</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(cSocket.getInputStream()));</span><br><span class="line">    bufferedReader.lines().forEach(s -&gt; System.out.println(<span class="string">&quot;客户端：&quot;</span> + s));</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 accept 方法，阻塞等待客户端连接；</li><li>利用 Socket 模拟了一个简单的客户端，只进行连接、读取和打印；</li></ul><p>在 Java 中，线程的实现是比较重量级的，所以线程的启动或者销毁是很消耗服务器的资源的，即使使用线程池来实现，使用上述传统的 Socket 方式，当连接数极具上升也会带来性能瓶颈，原因是线程的上线文切换开销会在高并发的时候体现的很明显，并且以上操作方式还是同步阻塞式的编程，性能问题在高并发的时候就会体现的尤为明显。</p><p><img src="http://icdn.apigo.cn/blog/javacore-io-005.png" alt="img"></p><p>Writer、Reader 基于字符操作的 IO</p><p>File 基于磁盘操作的 IO</p><p>Socket 基于网络操作的 IO</p><h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><h3 id="Hashmap是怎么实现的，底层原理？"><a href="#Hashmap是怎么实现的，底层原理？" class="headerlink" title="Hashmap是怎么实现的，底层原理？"></a>Hashmap是怎么实现的，底层原理？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 当resize操作时候发现链表长度小于6时，从红黑树退化为链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于存储map中key和value的结构体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>transient Node&lt;K,V&gt;[] table;</code>这表示HashMap是Node数组构成，其中Node类的实现如下，为HashMap的内部类，可以看出这其实就是个链表，链表的每个结点是一个&lt;K,V&gt;映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transient int modCount;``modCount</code>在<code>HashMap</code>，<code>ArrayList</code>和<code>LinkedList</code>中都有，不同之处ArrayList和LinkedList中的modCount继承自<code>AbstractList</code>的<code>protected transient int modCount = 0；</code></p><blockquote><p>在一个迭代器初始的时候会赋予它调用这个迭代器的对象的modCount，如果在迭代器遍历的过程中，<strong>一旦发现这个对象的modCount和迭代器中存储的modCount不一样那就抛异常。</strong></p><p><strong>Fail-Fast机制</strong>：java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，<strong>对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</strong>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map。</p></blockquote><p><strong>注意初始容量和扩容后的容量都必须是2的次幂</strong>，为什么呢?</p><p><strong>hash方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的散列方法如上，其实就是将hash值的高16位和低16位异或，我们将马上看到hash在与n - 1相与的时候，高位的信息也被考虑了，能使碰撞的概率减小，散列得更均匀。</p><p>在JDK 8中，HashMap的putVal方法中有这么一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>关键就是这句<code>(n - 1) &amp; hash</code>，<strong>这行代码是把待插入的结点散列到数组中某个下标中</strong>。</p><p>为什么HashMap的容量要始终保持2的次幂？</p><ul><li><strong>使散列值分布均匀</strong></li><li><strong>位运算的效率比取余的效率高</strong></li></ul><p>注意table.length是数组的容量，而<code>transient int size</code>表示存入Map中的键值对数。</p><p><code>int threshold</code>表示临界值，当键值对的个数大于临界值，就会扩容。threshold的更新是由下面的方法完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该方法返回大于等于cap的最小的二次幂数值。比如cap为16，就返回16，cap为17就返回32。</p><p><strong>put方法</strong></p><p>put方法主要由putVal方法实现：</p><ul><li>如果没有产生hash冲突，直接在数组<code>tab[i = (n - 1) &amp; hash]</code>处新建一个结点；</li><li>否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值</li><li>否则，如果数组下标中的类型是TreeNode，就插入到红黑树中</li><li>如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。接着判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）</li></ul><p><strong>get方法</strong></p><p>get方法由getNode方法实现：</p><ul><li>如果在数组下标的链表头就找到key相同的，那么返回链表头的值</li><li>否则如果数组下标处的类型是TreeNode，就在红黑树中查找</li><li>否则就是在普通链表中查找了</li><li>都找不到就返回null</li></ul><p>remove方法的流程大致和get方法类似。</p><p><strong>HashMap的扩容，resize()过程？</strong></p><p>newCap = oldCap &lt;&lt; 1;</p><p>resize方法中有这么一句，说明是扩容后数组大小是原数组的两倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 如果数组中只有一个元素，即只有一个头结点，重新哈希到新数组的某个下标</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 数组下标处的链表长度大于1，非红黑树的情况</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// oldCap是2的次幂，最高位是1，其余为是0，哈希值和其相与，根据哈希值的最高位是1还是0，链表被拆分成两条，哈希值最高位是0分到loHead。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 哈希值最高位是1分到hiHead</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// loHead挂到新数组[原下标]处；</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// hiHead挂到新数组中[原下标+oldCap]处</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><p>举个例子，比如oldCap是16，二进制表示是10000，hash值的后五位和oldCap相与，因为oldCap的最高位（从右往左数的第5位）是1其余位是0，因此hash值的该位是0的所有元素被分到一条链表，挂到新数组中原下标处，hash值该位为1的被分到另外一条链表，挂到新数组中原下标+oldCap处。举个例子：桶0中的元素其hash值后五位是0XXXX的就被分到桶0种，其hash值后五位是1XXXX就被分到桶4中。</p><h3 id="HashTable通过synchronized实现线程安全"><a href="#HashTable通过synchronized实现线程安全" class="headerlink" title="HashTable通过synchronized实现线程安全"></a><code>HashTable</code>通过synchronized实现线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p>ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>　　Segment继承了<code>ReentrantLock</code>，所以它就是一种可重入锁。在<code>ConcurrentHashMap</code>，一个Segment就是一个子哈希表，Segment里维护了一个<code>HashEntry</code>数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的<code>ConcurrentLevel</code>为16来讲，理论上就允许16个线程并发执行）</p><p><strong>所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。</strong>　　</p><h2 id="7、transient关键词使用"><a href="#7、transient关键词使用" class="headerlink" title="7、transient关键词使用"></a>7、transient关键词使用</h2><p>Java语言的关键字，变量修饰符，如果用<strong>transient</strong>声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p><p>Java的<strong>serialization提供了一种持久化对象实例的机制</strong>。当持久化对象时，有一个特殊的对象数据成员，不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p><h2 id="8、Java中的错误和异常？"><a href="#8、Java中的错误和异常？" class="headerlink" title="8、Java中的错误和异常？"></a>8、Java中的错误和异常？</h2><p>Java中的所有异常都是Throwable的子类对象，Error类和Exception类是Throwable类的两个直接子类。</p><p>Error：包括一些严重的、程序不能处理的系统错误类。这些错误一般不是程序造成的，比如StackOverflowError和OutOfMemoryError。</p><p>Exception：异常分为运行时异常和检查型异常。</p><ul><li>检查型异常要求必须对异常进行处理，要么往上抛，要么try-catch捕获，不然不能通过编译。这类异常比较常见的是IOException。</li><li>运行时异常，可处理可不处理，在编译时可以通过，异常在运行时才暴露。比如数组下标越界，除0异常等。</li></ul><h2 id="9、Java的集合类框架介绍一下？"><a href="#9、Java的集合类框架介绍一下？" class="headerlink" title="9、Java的集合类框架介绍一下？"></a>9、Java的集合类框架介绍一下？</h2><p>首先接口Collection和Map是平级的，Map没有实现Collection。</p><p>Map的实现类常见有HashMap、TreeMap、LinkedHashMap和HashTable等。其中HashMap使用散列法实现，低层是数组，采用链地址法解决哈希冲突，每个数组的下标都是一条链表，当长度超过8时，转换成红黑树。TreeMap使用红黑树实现，可以按照键进行排序。LinkedHashMap的实现综合了HashMap和双向链表，可保证以插入时的顺序（或访问顺序，LRU的实现）进行迭代。HashTable和HashMap比，前者是线程安全的，后者不是线程安全的。HashTable的键或者值不允许null，HashMap允许。</p><p>Collection的实现类常见的有List、Set和Queue。List的实现类有ArrayList和LinkedList以及Vector等，ArrayList就是一个可扩容的对象数组，LinkedList是一个双向链表。Vector是线程安全的（ArrayList不是线程安全的）。Set里的元素不可重复，实现类常见的有HashSet、TreeSet、LinkedHashSet等，HashSet的实现基于HashMap，实际上就是HashMap中的Key，同样TreeSet低层由TreeMap实现，LinkedHashSet低层由LinkedHashMap实现。Queue的实现类有LinkedList，可以用作栈、队列和双向队列，另外还有PriorityQueue是基于堆的优先队列。</p><h2 id="10、Java反射是什么？为什么要用反射，有什么好处，哪些地方用到了反射？"><a href="#10、Java反射是什么？为什么要用反射，有什么好处，哪些地方用到了反射？" class="headerlink" title="10、Java反射是什么？为什么要用反射，有什么好处，哪些地方用到了反射？"></a>10、Java反射是什么？为什么要用反射，有什么好处，哪些地方用到了反射？</h2><p>反射：允许任意一个类在运行时获取自身的类信息，并且可以操作这个类的方法和属性。这种动态获取类信息和动态调用对象方法的功能称为Java的反射机制。</p><p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性。它不需要事先（写代码的时候或编译期）知道运行对象是谁，如<code>Class.ForName()</code>根本就没有指定某个特定的类，完全由你传入的类全限定名决定，而通过new的方式你是知道运行时对象是哪个类的。 反射避免了将程序“写死”。</p><p>反射可以降低程序耦合性，提高程序的灵活性。new是造成紧耦合的一大原因。比如下面的工厂方法中，根据水果类型决定返回哪一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">getFruit</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Apple&quot;</span>.equals(type)) &#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Banana&quot;</span>.equals(type)) &#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Banana();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Orange&quot;</span>.equals(type)) &#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fruit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>但是我们事先并不知道之后会有哪些类，比如新增了Mango，就需要在if-else中新增；如果以后不需要Banana了就需要从if-else中删除。这就是说只要子类变动了，我们必须在工厂类进行修改，然后再编译。如果用反射呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">getFruit</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fruit = (Fruit) Class.forName(type).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fruit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果再将子类的全限定名存放在配置文件中。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">class-type</span>=<span class="string">com.fruit.Apple</span></span><br></pre></td></tr></table></figure><p>那么不管新增多少子类，根据不同的场景只需修改文件就好了，上面的代码无需修改代码、重新编译，就能正确运行。</p><p>哪些地方用到了反射？举几个例子</p><ul><li>加载数据库驱动时</li><li>Spring的IOC容器，根据XML配置文件中的类全限定名动态加载类</li><li>工厂方法模式中（如上）</li></ul><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><h5 id="获取class实例的方式"><a href="#获取class实例的方式" class="headerlink" title="获取class实例的方式"></a>获取class实例的方式</h5><ol><li><p>直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure></li><li><p>如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure></li><li><p>如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>因为<code>Class</code>实例在JVM中是唯一的。所以获取的String实例是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class a = String.class;</span><br><span class="line">Class b = <span class="string">&quot;Hello&quot;</span>.getClass();</span><br><span class="line">a == b; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="和instanceof的区别"><a href="#和instanceof的区别" class="headerlink" title="== 和instanceof的区别"></a>== 和instanceof的区别</h5><p>用<code>instanceof</code>不但匹配当前类型，还匹配当前类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。 也就是如果该类是子类<code>instanceof</code>也返回true，但是==返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n.getClass() == Integer.class; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n.getClass() == Number.class; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意到数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</p><p>获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例。</p><h5 id="JVM动态加载"><a href="#JVM动态加载" class="headerlink" title="JVM动态加载"></a>JVM动态加载</h5><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</p><h5 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h5><p>通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类</li></ul><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>通过<code>Field.set(Object, Object)</code>实现修改字段的值，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Student s = <span class="keyword">new</span> Student(<span class="number">15</span>,<span class="string">&quot;djj&quot;</span>,<span class="number">96</span>);</span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="number">16</span>,<span class="string">&quot;why&quot;</span>,<span class="number">97</span>);</span><br><span class="line">    Class cls = s.getClass();</span><br><span class="line">    Field f = cls.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">    System.out.println(f.get(s)); <span class="comment">//96</span></span><br><span class="line">    System.out.println(f.get(s1)); <span class="comment">//97</span></span><br><span class="line">    f.set(s, <span class="number">56</span>);</span><br><span class="line">    System.out.println(s.getScore());<span class="comment">//56</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。调用非public方法</li></ul><h6 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">45</span>];</span><br><span class="line"></span><br><span class="line">delete a;</span><br></pre></td></tr></table></figure><h6 id="调用非静态方法"><a href="#调用非静态方法" class="headerlink" title="调用非静态方法"></a>调用非静态方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h6><p>和Field类似，对于非public方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造实例"><a href="#构造实例" class="headerlink" title="构造实例"></a>构造实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>局限：它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过<code>Class.newInstance()</code>来调用。</p><p>Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例</p><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p><code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取父类，实现接口"><a href="#获取父类，实现接口" class="headerlink" title="获取父类，实现接口"></a>获取父类，实现接口</h5><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="11、说说你对面向对象、封装、继承、多态的理解？"><a href="#11、说说你对面向对象、封装、继承、多态的理解？" class="headerlink" title="11、说说你对面向对象、封装、继承、多态的理解？"></a>11、说说你对面向对象、封装、继承、多态的理解？</h2><ul><li>封装：隐藏实现细节，明确标识出允许外部使用的所有成员函数和数据项。 防止代码或数据被破坏。</li><li>继承：子类继承父类，拥有父类的所有功能，并且可以在父类基础上进行扩展。实现了代码重用。子类和父类是兼容的，外部调用者无需关注两者的区别。</li><li>多态：一个接口有多个子类或实现类，在运行期间（而非编译期间）才决定所引用的对象的实际类型，再根据其实际的类型调用其对应的方法，也就是“动态绑定”。</li></ul><p>Java实现多态有三个必要条件<strong>：继承、重写、向上转型。</strong></p><ul><li>继承：子类继承或者实行父类</li><li>重写：在子类里面重写从父类继承下来的方法</li><li>向上转型：父类引用指向子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. Cat继承了Animal</span></span><br><span class="line"><span class="comment">         * 2. Cat重写了Animal的eat方法</span></span><br><span class="line"><span class="comment">         * 3. 父类Animal的引用指向了子类Cat。</span></span><br><span class="line"><span class="comment">         * 在编译期间其静态类型为Animal;在运行期间其实际类型为Cat，因此animal.eat()将选择Cat的eat方法而不是其他子类的eat方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        printEating(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEating</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、实现不可变对象的策略？比如JDK中的String类。"><a href="#12、实现不可变对象的策略？比如JDK中的String类。" class="headerlink" title="12、实现不可变对象的策略？比如JDK中的String类。"></a>12、实现不可变对象的策略？比如JDK中的String类。</h2><ul><li>不提供setter方法（包括修改字段、字段引用到的的对象等方法）</li><li>将所有字段设置为final、private</li><li>将类修饰为final，不允许子类继承、重写方法。可以将构造函数设为private，通过工厂方法创建。</li><li>如果类的字段是对可变对象的引用，不允许修改被引用对象。 1）不提供修改可变对象的方法；2）不共享对可变对象的引用。对于外部传入的可变对象，不保存该引用。如要保存可以保存其复制后的副本；对于内部可变对象，不要返回对象本身，而是返回其复制后的副本。</li></ul><h2 id="13、Java序列话中如果有些字段不想进行序列化，怎么办？"><a href="#13、Java序列话中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="13、Java序列话中如果有些字段不想进行序列化，怎么办？"></a>13、Java序列话中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用<strong>transient</strong>关键字修饰。功能是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p><h2 id="14、-和equals的区别？"><a href="#14、-和equals的区别？" class="headerlink" title="14、==和equals的区别？"></a>14、==和equals的区别？</h2><p>== 对于基本类型，比较值是否相等，对于对象，比较的是两个对象的地址是否相同，即是否是指相同一个对象。</p><p>equals的默认实现实际上使用了==来比较两个对象是否相等，但是像Integer、String这些类对equals方法进行了重写，比较的是两个对象的内容是否相等。</p><p>对于Integer，如果依然坚持使用==来比较，有一些要注意的地方。对于[-128,127]区间里的数，有一个缓存。因此</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">Integer b = <span class="number">128</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过采用new的方式，a在堆中，这里打印false</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>对于String，因为它有一个常量池。所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;gg&quot;</span> + <span class="string">&quot;rr&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;ggrr&quot;</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然牵涉到new的话，该对象就在堆上创建了，所以这里打印false</span></span><br><span class="line">String a = <span class="string">&quot;gg&quot;</span> + <span class="string">&quot;rr&quot;</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;ggrr&quot;</span>);</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><h2 id="15、接口和抽象类的区别？"><a href="#15、接口和抽象类的区别？" class="headerlink" title="15、接口和抽象类的区别？"></a>15、接口和抽象类的区别？</h2><ul><li>Java不能多继承，一个类只能继承一个抽象类；但是可以实现多个接口。</li><li>继承抽象类是一种IS-A的关系，实现接口是一种LIKE-A的关系。</li><li>继承抽象类可以实现对父类代码的复用，也可以重写抽象方法实现子类特有的功能。实现接口可以为类新增额外的功能。</li><li>抽象类定义基本的共性内容，接口是定义额外的功能。</li><li>调用者使用动机不同, 实现接口是为了使用他规范的某一个行为；继承抽象类是为了使用这个类属性和行为.</li></ul><h2 id="16、给你一个Person对象p，如何将该对象变成JSON表示？"><a href="#16、给你一个Person对象p，如何将该对象变成JSON表示？" class="headerlink" title="16、给你一个Person对象p，如何将该对象变成JSON表示？"></a>16、给你一个Person对象p，如何将该对象变成JSON表示？</h2><p>本质是考察Java反射，因为要实现一个通用的程序。实现可能根本不知道该类有哪些字段，所以不能通过get和set等方法来获取键-值。使用反射的getDeclaredFields()可以获得其声明的字段。如果字段是private的，需要调用该字段的<code>f.setAccessible(true);</code>，才能读取和修改该字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object2Json</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; classPerson = p.getClass();</span><br><span class="line">        Field[] fields = classPerson.getDeclaredFields();</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Field f: fields) &#123;</span><br><span class="line">            <span class="comment">// 对于private字段要先设置accessible为true</span></span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            map.put(String.valueOf(f.getName()), String.valueOf(f.get(p)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到了map，再弄成JSON标准格式就好了。</p><h2 id="17、JDBC中sql查询的完整过程？操作事务呢？"><a href="#17、JDBC中sql查询的完整过程？操作事务呢？" class="headerlink" title="17、JDBC中sql查询的完整过程？操作事务呢？"></a>17、JDBC中sql查询的完整过程？操作事务呢？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.建立连接</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 执行sql语句使用的Statement或者PreparedStatment</span></span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select * from stu;&quot;</span>;</span><br><span class="line">    ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        <span class="comment">// 第一列是id，所以从第二行开始</span></span><br><span class="line">        String name = resultSet.getString(<span class="number">2</span>); <span class="comment">// 可以传入列的索引，1代表第一行，索引不是从0开始</span></span><br><span class="line">        <span class="keyword">int</span> age = resultSet.getInt(<span class="number">3</span>);</span><br><span class="line">        String gender = resultSet.getString(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;学生姓名：&quot;</span> + name + <span class="string">&quot; | 年龄：&quot;</span> + age + <span class="string">&quot; | 性别：&quot;</span> + gender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    <span class="comment">// 关闭statemenet</span></span><br><span class="line">    statement.close();</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ResultSet维持一个指向当前行记录的cursor（游标）指针</strong></p><ul><li>注册驱动</li><li>建立连接</li><li>准备sql语句</li><li>执行sql语句得到结果集</li><li>对结果集进行遍历</li><li>关闭结果集（ResultSet）</li><li>关闭statement</li><li>关闭连接（connection）</li></ul><p>由于JDBC默认自动提交事务，每执行一个update ,delete或者insert的时候都会自动提交到数据库，无法回滚事务。所以若需要实现事务的回滚，要指定<code>setAutoCommit(false)</code>。</p><ul><li><code>true</code>：sql命令的提交（commit）由驱动程序负责</li><li><code>false</code>：sql命令的提交由应用程序负责，程序必须调用commit或者rollback方法</li></ul><p>JDBC操作事务的格式如下，在捕获异常中进行事务的回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  con.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//开启事务…</span></span><br><span class="line">  ….</span><br><span class="line">  …</span><br><span class="line">  con.commit();<span class="comment">//try的最后提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">  con.rollback();<span class="comment">//回滚事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18、实现单例，有哪些要注意的地方？"><a href="#18、实现单例，有哪些要注意的地方？" class="headerlink" title="18、实现单例，有哪些要注意的地方？"></a>18、实现单例，有哪些要注意的地方？</h2><p>就普通的实现方法来看。</p><ul><li>不允许在其他类中直接new出对象，故构造方法私有化</li><li>在本类中创建唯一一个static实例对象</li><li>定义一个public static方法，返回该实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 饿汉模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp singletonImp = <span class="keyword">new</span> SingletonImp();</span><br><span class="line">    <span class="comment">// 私有化（private）该类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonImp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式：线程安全，不能延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonImp4 singletonImp4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonImp4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonImp4 = <span class="keyword">new</span> SingletonImp4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonImp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检测锁+volatile禁止语义重排。因为<code>singletonImp4 = new SingletonImp4();</code>不是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门用于创建Singleton的静态类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp6 singletonImp6 = <span class="keyword">new</span> SingletonImp6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.singletonImp6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类，可以实现延迟加载。</p><p>最推荐的是单一元素枚举实现单例。</p><ul><li>写法简单</li><li>枚举实例的创建默认就是线程安全的</li><li>提供了自由的序列化机制。面对复杂的序列或反射攻击，也能保证是单例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOtherMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19、覆写Object方法"><a href="#19、覆写Object方法" class="headerlink" title="19、覆写Object方法"></a>19、覆写Object方法</h2><ul><li><code>toString()</code>：把instance输出为<code>String</code>；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。</li></ul><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用 。</p><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code> 。<code>final</code>修饰符有多种作用：</p><h2 id="20、final关键词"><a href="#20、final关键词" class="headerlink" title="20、final关键词"></a>20、final关键词</h2><ul><li><code>final</code>修饰的方法可以阻止被覆写；</li><li><code>final</code>修饰的class可以阻止被继承；</li><li><code>final</code>修饰的field必须在创建对象时初始化，随后不可修改。</li></ul><h2 id="21、抽象类和接口"><a href="#21、抽象类和接口" class="headerlink" title="21、抽象类和接口"></a>21、抽象类和接口</h2><h5 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h5><table><thead><tr><th align="left"></th><th align="left">abstract class</th><th align="left">interface</th></tr></thead><tbody><tr><td align="left">继承</td><td align="left">只能extends一个class</td><td align="left">可以implements多个interface</td></tr><tr><td align="left">字段</td><td align="left">可以定义实例字段</td><td align="left">不能定义实例字段</td></tr><tr><td align="left">抽象方法</td><td align="left">可以定义抽象方法</td><td align="left">可以定义抽象方法</td></tr><tr><td align="left">非抽象方法</td><td align="left">可以定义非抽象方法</td><td align="left">可以定义default方法</td></tr></tbody></table><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h5 id="interface字段"><a href="#interface字段" class="headerlink" title="interface字段"></a>interface字段</h5><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22、作用域"><a href="#22、作用域" class="headerlink" title="22、作用域"></a>22、作用域</h2><h5 id="package包作用域"><a href="#package包作用域" class="headerlink" title="package包作用域"></a>package包作用域</h5><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><p><code>public</code>、<code>protected</code>、<code>private</code>略</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><h2 id="23、异常和错误"><a href="#23、异常和错误" class="headerlink" title="23、异常和错误"></a>23、异常和错误</h2><p>Error和RuntimeException是非受查异常，其他的异常为受查异常。</p><p>在程序中无须将非受查异常进行catch或者throws。</p><p>在测试阶段可以使用断言来进行。</p><h5 id="常见的RuntimeException异常"><a href="#常见的RuntimeException异常" class="headerlink" title="常见的RuntimeException异常"></a>常见的RuntimeException异常</h5><p>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常</p><h5 id="常见的CheckedException异常"><a href="#常见的CheckedException异常" class="headerlink" title="常见的CheckedException异常"></a>常见的CheckedException异常</h5><p>SQLException<br>OException<br>ClassNotFoundException<br>NamingException,<br>ServletException,</p><h2 id="24、迭代器"><a href="#24、迭代器" class="headerlink" title="24、迭代器"></a>24、迭代器</h2><p>迭代器就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。</p><h5 id="Iterator接口的实现如下"><a href="#Iterator接口的实现如下" class="headerlink" title="Iterator接口的实现如下"></a><code>Iterator</code>接口的实现如下</h5><ol><li><p>迭代器在迭代期间可以从集合中移除元素。</p></li><li><p>方法名得到了改进，Enumeration的方法名称都比较长。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a><code>Iterable</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterators;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个Iterator对象</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 两种遍历方式</span><br><span class="line"></span><br><span class="line">使用迭代器遍历和使用&#96;&#96;&#96;foreach&#96;&#96;&#96;遍历</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">		LinkedList&lt;String&gt; linkedList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        linkedList.push(&quot;first&quot;);</span><br><span class="line">        linkedList.push(&quot;second&quot;);</span><br><span class="line">        linkedList.push(&quot;third&quot;);</span><br><span class="line">        linkedList.push(&quot;forth&quot;);</span><br><span class="line">        linkedList.push(&quot;fifth&quot;);</span><br><span class="line">        Iterator&lt;String&gt; linkedListIterable &#x3D; linkedList.iterator();</span><br><span class="line"></span><br><span class="line">        while(linkedListIterable.hasNext())&#123;</span><br><span class="line">            System.out.println(linkedListIterable.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String string:linkedList) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在使用Iterator的时候禁止对所遍历的容器进行改变其大小结构的操作。例如: 在使用Iterator进行迭代时，如果对集合进行了add、remove操作就会出现<code>ConcurrentModificationException</code>异常。</p><h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a><code>ListIterator</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/" title="Java 基础" target="_blank" rel="external">https://duanjiaojiao316.github.io/2019/12/15/Java%E5%9F%BA%E7%A1%80/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/duanjiaojiao316" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/duanjiaojiao316" target="_blank"><span class="text-dark">熟悉路线站点</span><small class="ml-1x">Developer &amp; Designer</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/02/21/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>