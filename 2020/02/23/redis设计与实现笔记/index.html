<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>阅读redis设计与实现笔记 | 熟悉路线站点</title><meta name="description" content="redis设计与实现笔记  第一部分 数据结构与对象  1.简单动态字符串  2.链表  3.字典  4.跳跃表  5.整数集合  6.压缩列表  7.对象  第二部分 单机数据库的实现  9.数据库  10.RDB持久化  11.AOF持久化  12.事件  13.客户端  14.服务器端  第三部分 多机数据库的实现  15.复制  16.Sential  17.集群  第四部分 独立功能的"><meta property="og:type" content="article"><meta property="og:title" content="阅读redis设计与实现笔记"><meta property="og:url" content="https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="熟悉路线站点"><meta property="og:description" content="redis设计与实现笔记  第一部分 数据结构与对象  1.简单动态字符串  2.链表  3.字典  4.跳跃表  5.整数集合  6.压缩列表  7.对象  第二部分 单机数据库的实现  9.数据库  10.RDB持久化  11.AOF持久化  12.事件  13.客户端  14.服务器端  第三部分 多机数据库的实现  15.复制  16.Sential  17.集群  第四部分 独立功能的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/D:%5C%E9%9D%A2%E8%AF%95%5Cspringbootimages%5Cimage-20191124211640527.png"><meta property="article:published_time" content="2020-02-23T12:57:04.000Z"><meta property="article:modified_time" content="2021-05-11T07:46:36.144Z"><meta property="article:author" content="duanjiaojiao"><meta property="article:tag" content="redis"><meta property="article:tag" content="阅读笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/D:%5C%E9%9D%A2%E8%AF%95%5Cspringbootimages%5Cimage-20191124211640527.png"><link rel="canonical" href="https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/index.html"><link rel="alternate" href="/atom.xml" title="熟悉路线站点" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.2.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/duanjiaojiao316" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">熟悉路线站点</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Developer &amp; Designer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">书单</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HyperLogLog/" rel="tag">HyperLogLog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-%E5%91%BD%E4%BB%A4/" rel="tag">Python 命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E5%91%BD%E4%BB%A4/" rel="tag">mysql命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%96%87/" rel="tag">回文</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" rel="tag">算法 BFS（广度优先搜索）</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">BFS（广度优先搜索）</a> <a href="/tags/HyperLogLog/" style="font-size:13px">HyperLogLog</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size:13px">Java基础</a> <a href="/tags/Kafka/" style="font-size:13px">Kafka</a> <a href="/tags/Python-%E5%91%BD%E4%BB%A4/" style="font-size:13px">Python 命令</a> <a href="/tags/Redis/" style="font-size:13px">Redis</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/mybatis/" style="font-size:13px">mybatis</a> <a href="/tags/mysql%E5%91%BD%E4%BB%A4/" style="font-size:13px">mysql命令</a> <a href="/tags/redis/" style="font-size:14px">redis</a> <a href="/tags/%E5%9B%9E%E6%96%87/" style="font-size:13px">回文</a> <a href="/tags/%E7%AE%97%E6%B3%95-BFS%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/" style="font-size:13px">算法 BFS（广度优先搜索）</a> <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" style="font-size:13px">阅读笔记</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/05/18/Python-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/" class="title">Python 第三方库国内镜像</a></p><p class="item-date"><time datetime="2021-05-18T07:36:54.000Z" itemprop="datePublished">2021-05-18</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p><p class="item-title"><a href="/2021/05/10/Redis%E6%8F%90%E4%BE%9B%E4%B8%8D%E7%B2%BE%E7%A1%AE%E7%9A%84%E5%8E%BB%E9%87%8D%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88HyperLogLog/" class="title">Redis提供不精确的去重技术方案HyperLogLog</a></p><p class="item-date"><time datetime="2021-05-10T14:40:03.000Z" itemprop="datePublished">2021-05-10</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/05/06/Redis%E4%BD%8D%E5%9B%BE/" class="title">Redis位图</a></p><p class="item-date"><time datetime="2021-05-06T14:45:00.000Z" itemprop="datePublished">2021-05-06</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/04/26/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="title">Redis分布式锁</a></p><p class="item-date"><time datetime="2021-04-26T13:10:30.000Z" itemprop="datePublished">2021-04-26</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p><p class="item-title"><a href="/2021/04/25/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" class="title">Redis主从架构数据同步原理</a></p><p class="item-date"><time datetime="2021-04-25T15:11:33.000Z" itemprop="datePublished">2021-04-25</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-redis设计与实现笔记" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">阅读redis设计与实现笔记</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/" class="article-date"><time datetime="2020-02-23T12:57:04.000Z" itemprop="datePublished">2020-02-23</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/redis/" rel="tag">redis</a>, <a class="article-tag-link-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 5.4k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 19(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="redis设计与实现笔记"><a class="markdownIt-Anchor" href="#redis设计与实现笔记"></a> redis设计与实现笔记</h1><h2 id="第一部分-数据结构与对象"><a class="markdownIt-Anchor" href="#第一部分-数据结构与对象"></a> 第一部分 数据结构与对象</h2><h3 id="1简单动态字符串"><a class="markdownIt-Anchor" href="#1简单动态字符串"></a> 1.简单动态字符串</h3><h3 id="2链表"><a class="markdownIt-Anchor" href="#2链表"></a> 2.链表</h3><h3 id="3字典"><a class="markdownIt-Anchor" href="#3字典"></a> 3.字典</h3><h3 id="4跳跃表"><a class="markdownIt-Anchor" href="#4跳跃表"></a> 4.跳跃表</h3><h3 id="5整数集合"><a class="markdownIt-Anchor" href="#5整数集合"></a> 5.整数集合</h3><h3 id="6压缩列表"><a class="markdownIt-Anchor" href="#6压缩列表"></a> 6.压缩列表</h3><h3 id="7对象"><a class="markdownIt-Anchor" href="#7对象"></a> 7.对象</h3><h2 id="第二部分-单机数据库的实现"><a class="markdownIt-Anchor" href="#第二部分-单机数据库的实现"></a> 第二部分 单机数据库的实现</h2><h3 id="9数据库"><a class="markdownIt-Anchor" href="#9数据库"></a> 9.数据库</h3><h3 id="10rdb持久化"><a class="markdownIt-Anchor" href="#10rdb持久化"></a> 10.RDB持久化</h3><h3 id="11aof持久化"><a class="markdownIt-Anchor" href="#11aof持久化"></a> 11.AOF持久化</h3><h3 id="12事件"><a class="markdownIt-Anchor" href="#12事件"></a> 12.事件</h3><h3 id="13客户端"><a class="markdownIt-Anchor" href="#13客户端"></a> 13.客户端</h3><h3 id="14服务器端"><a class="markdownIt-Anchor" href="#14服务器端"></a> 14.服务器端</h3><h2 id="第三部分-多机数据库的实现"><a class="markdownIt-Anchor" href="#第三部分-多机数据库的实现"></a> 第三部分 多机数据库的实现</h2><h3 id="15复制"><a class="markdownIt-Anchor" href="#15复制"></a> 15.复制</h3><h3 id="16sential"><a class="markdownIt-Anchor" href="#16sential"></a> 16.Sential</h3><h3 id="17集群"><a class="markdownIt-Anchor" href="#17集群"></a> 17.集群</h3><h2 id="第四部分-独立功能的实现"><a class="markdownIt-Anchor" href="#第四部分-独立功能的实现"></a> 第四部分 独立功能的实现</h2><h3 id="18发布与订阅"><a class="markdownIt-Anchor" href="#18发布与订阅"></a> 18.发布与订阅</h3><h3 id="19事务"><a class="markdownIt-Anchor" href="#19事务"></a> 19.事务</h3><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p><code>Redis</code> 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h4 id="为什么redis不支持回滚"><a class="markdownIt-Anchor" href="#为什么redis不支持回滚"></a> <strong>为什么<code>Redis</code>不支持回滚</strong></h4><p><code>Redis</code>命令在事务中可能会执行失败，但是<code>Redis</code>事务不会回滚，而是继续会执行余下的命令。如果您有一个关系型数据库的知识，这对您来说可能会感到奇怪，因为关系型数据在这种情况下都是会回滚的。</p><p><code>Redis</code>这样做，主要是因为:只有当发生语法错误(这个问题在命令队列时无法检测到)了，<code>Redis</code>命令才会执行失败, 或对keys赋予了一个类型错误的数据：这意味着这些都是程序性错误，这类错误在开发的过程中就能够发现并解决掉，几乎不会出现在生产环境。由于不需要回滚，这使得<code>Redis</code>内部更加简单，而且运行速度更快。</p><h3 id="20lua脚本"><a class="markdownIt-Anchor" href="#20lua脚本"></a> 20.lua脚本</h3><h3 id="21排序"><a class="markdownIt-Anchor" href="#21排序"></a> 21.排序</h3><h3 id="22二进制数组"><a class="markdownIt-Anchor" href="#22二进制数组"></a> 22.二进制数组</h3><ul><li><code>SETBIT</code>为二进制数组指定偏移上的二进制位设置值</li><li><code>GETBIT</code>获取二进制数组中指定偏移的二进制位的值</li><li><code>BITCOUNT</code>计算二进制数组中以1为值的二进制位有多少个</li><li><code>BITOP</code>可以对多个二进制数组进行按位与、按位或、按位异或、取反等操作。</li></ul><p>字符串对象表示位数组，因为字符串对象使用SDS数据结构是二进制安全的，可以直接使用SDS数据结构来保存维数组。</p><p>SDS数据结构中buf数组中的顺序和平时书写顺序相反。</p><h3 id="23慢查询日志"><a class="markdownIt-Anchor" href="#23慢查询日志"></a> 23.慢查询日志</h3><p>记录执行时间超过给定时长的命令请求，用户通过慢日志查询的日志来监视和优化查询速度。</p><ul><li><code>slowlog-log-slower-than</code> 指定执行时间超过多少微妙的命令请求会被记录在日志之中。设置为0，所有的请求都会记录在日志中。</li><li><code>slowlog-log-max-len</code>指定服务器最多可以保存多少命令请求。如果设置为5，服务器最多只能存储5个命令请求，以先进先出的方式保存，如果指令数量已经是<code>slowlog-log-max-len</code>，删除最旧的命令请求添加新的命令请求。</li></ul><p><code>SLOWLOG GET</code>命令查看服务器存储的慢查询日志。</p><p><img src="/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/D:%5C%E9%9D%A2%E8%AF%95%5Cspringbootimages%5Cimage-20191124211640527.png" alt="image-20191124211640527"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">time_t</span> time;<span class="comment">//命令执行时的时间，Unix时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;<span class="comment">//执行命令消耗的时间</span></span><br><span class="line">    robj **argv;<span class="comment">//命令与命令参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//命令与命令参数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SLOWLOG_RESET</code>清除慢查询日志中的所有日志。</p><p>添加新的日志</p><ol><li>检查是否超过<code>slowlog-log-slower-than</code> ，如果查过创建一个新的日志添加在<code>slowlog</code>链表的表头。</li><li>判断链表的长度是否查过<code>slowlog-log-max-len</code>，如果查过就从链表的表尾删除一个。</li></ol><h3 id="24监视器"><a class="markdownIt-Anchor" href="#24监视器"></a> 24.监视器</h3><p>通过MONITOR 命令客户端将自己变为一个监视器，实时接收打印服务器端处理命令请求的信息。当一个客户端向服务器发送一个请求，服务器除了处理命令请求还会将所有的信息发送给所有的监视器。</p><p><code>list *monitor</code> 记录打开REDIS_MONITOR标志的客户端，也就是将自己变成监视器的客户端。</p><p>服务器端调用<code>replicationFeedMonitors</code>该函数来实现发送信息给所有监视器。</p><h2 id="第五部分-面试题"><a class="markdownIt-Anchor" href="#第五部分-面试题"></a> 第五部分 面试题</h2><h3 id="1redis-具体有-6-种内存淘汰策略"><a class="markdownIt-Anchor" href="#1redis-具体有-6-种内存淘汰策略"></a> 1.<code>Redis</code> 具体有 6 种内存淘汰策略：</h3><h4 id="内存淘汰策略"><a class="markdownIt-Anchor" href="#内存淘汰策略"></a> 内存淘汰策略</h4><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td><code>volatile-lru</code></td><td>从已设置过期时间的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td></tr><tr><td><code>volatile-ttl</code></td><td>从已设置过期时间的数据集中挑选<strong>更早过期</strong>的数据淘汰</td></tr><tr><td><code>volatile-random</code></td><td>从已设置过期时间的数据集中<strong>任意选择</strong>数据淘汰</td></tr><tr><td><code>allkeys-lru</code></td><td>从所有数据集中挑选<strong>最近最少使用</strong>的数据淘汰</td></tr><tr><td><code>allkeys-random</code></td><td>从所有数据集中<strong>任意选择</strong>数据进行淘汰</td></tr><tr><td><code>noeviction</code></td><td>当内存不足以容纳新写入数据时，<strong>新写入操作会报错</strong></td></tr></tbody></table><h4 id="redis-过期策略"><a class="markdownIt-Anchor" href="#redis-过期策略"></a> redis 过期策略</h4><p>redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p><p>所谓<strong>定期删除</strong>，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的<strong>灾难</strong>。实际上 redis 是每隔 100ms <strong>随机抽取</strong>一些 key 来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你<strong>获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</strong></p><blockquote><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p></blockquote><p>但是实际上这还是有问题的，如果定期删除<strong>漏掉了很多过期 key</strong>，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</p><p>答案是：<strong>走内存淘汰机制</strong>。</p><h3 id="2项目中缓存是如何使用的"><a class="markdownIt-Anchor" href="#2项目中缓存是如何使用的"></a> 2.项目中缓存是如何使用的？</h3><p>这个，需要结合自己项目的业务来。</p><h4 id="为什么要用缓存"><a class="markdownIt-Anchor" href="#为什么要用缓存"></a> 为什么要用缓存？</h4><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><h5 id="高性能"><a class="markdownIt-Anchor" href="#高性能"></a> 高性能</h5><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p><p>缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。</p><p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p><h5 id="高并发"><a class="markdownIt-Anchor" href="#高并发"></a> 高并发</h5><p>mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 <code>2000QPS</code> 也开始容易报警了。</p><p>所以要是你有个系统，高峰期一秒钟过来的请求有 1万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p><blockquote><p>缓存是走内存的，内存天然就支撑高并发。</p></blockquote><h3 id="3如何保证缓存与数据库的双写一致性"><a class="markdownIt-Anchor" href="#3如何保证缓存与数据库的双写一致性"></a> 3.如何保证缓存与数据库的双写一致性？</h3><p>一般来说，如果允许缓存和数据库偶尔有不一致的情况（要求不严格的情况下）最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，<strong>用比正常情况下多几倍的机器去支撑线上的一个请求</strong>。</p><h4 id="cache-aside-pattern"><a class="markdownIt-Anchor" href="#cache-aside-pattern"></a> Cache Aside Pattern</h4><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><h4 id="为什么是删除缓存而不是更新缓存"><a class="markdownIt-Anchor" href="#为什么是删除缓存而不是更新缓存"></a> <strong>为什么是删除缓存，而不是更新缓存？</strong></h4><ol><li>缓存的数据不是直接从数据库取出，而是经过复杂的计算</li><li>更新缓存的代价（频繁的数据库修改，频繁的缓存更新，但是却很少访问）只有用到的时候再重新计算放在缓存。</li></ol><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。<strong>用到缓存才去算缓存。</strong></p><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h4 id="不一致问题解决方法"><a class="markdownIt-Anchor" href="#不一致问题解决方法"></a> 不一致问题解决方法</h4><p>1.先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><blockquote><p>解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p></blockquote><p>2.数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p>在高并发下缓存出现这个问题：</p><blockquote><p>更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 <code>jvm</code> 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p></blockquote><h4 id="了解什么是-redis-的雪崩-穿透和击穿redis-崩溃之后会怎么样系统该如何应对这种情况如何处理-redis-的穿透"><a class="markdownIt-Anchor" href="#了解什么是-redis-的雪崩-穿透和击穿redis-崩溃之后会怎么样系统该如何应对这种情况如何处理-redis-的穿透"></a> 了解什么是 redis 的雪崩、穿透和击穿？redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 redis 的穿透？</h4><h5 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h5><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><blockquote><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul></blockquote><p>用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p>好处：</p><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li><li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li></ul><h5 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h5><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是<strong>黑客发出的恶意攻击</strong>。</p><p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p><p>举个例子：数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“<strong>视缓存于无物</strong>”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p>解决方式：</p><blockquote><p>每次系统 A 从数据库中只要没查到，就写一个<strong>空值</strong>到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据</p></blockquote><h5 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h5><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>解决方式：</p><blockquote><p>可以将热点数据设置为永远不过期；</p><p>基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p></blockquote><h3 id="4redis-和-memcached-有啥区别"><a class="markdownIt-Anchor" href="#4redis-和-memcached-有啥区别"></a> 4.redis 和 memcached 有啥区别？</h3><h4 id="redis-支持复杂的数据结构"><a class="markdownIt-Anchor" href="#redis-支持复杂的数据结构"></a> redis 支持复杂的数据结构</h4><p>redis 相比 memcached 来说，拥有<a target="_blank" rel="noopener" href="https://github.com/javazhiyin/advanced-java/blob/master/docs/high-concurrency/redis-data-types.md">更多的数据结构</a>，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， redis 会是不错的选择。</p><h4 id="redis-原生支持集群模式"><a class="markdownIt-Anchor" href="#redis-原生支持集群模式"></a> redis 原生支持集群模式</h4><p>在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p><h4 id="性能对比"><a class="markdownIt-Anchor" href="#性能对比"></a> 性能对比</h4><p>由于 redis 只使用<strong>单核</strong>，而 memcached 可以使用<strong>多核</strong>，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis。虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。</p><h3 id="5redis-都有哪些数据类型分别在哪些场景下使用比较合适"><a class="markdownIt-Anchor" href="#5redis-都有哪些数据类型分别在哪些场景下使用比较合适"></a> 5.redis 都有哪些数据类型？分别在哪些场景下使用比较合适？</h3><p>除非是面试官感觉看你简历，是工作 3 年以内的比较初级的同学，可能对技术没有很深入的研究，面试官才会问这类问题。否则，在宝贵的面试时间里，面试官实在不想多问。</p><p>其实问这个问题，主要有两个原因：</p><ul><li>看看你到底有没有全面的了解 redis 有哪些功能，一般怎么来用，啥场景用什么，就怕你别就会最简单的 KV 操作；</li><li>看看你在实际项目里都怎么玩儿过 redis。</li></ul><p>要是你回答的不好，没说出几种数据类型，也没说什么场景，你完了，面试官对你印象肯定不好，觉得你平时就是做个简单的 set 和 get。</p><h4 id="面试题剖析"><a class="markdownIt-Anchor" href="#面试题剖析"></a> 面试题剖析</h4><p>redis 主要有以下几种数据类型：</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>sorted set</li></ul><h5 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h5><p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set college szu</span><br></pre></td></tr></table></figure><h5 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h5><p>这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的<strong>某个字段</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hset person name bingo</span><br><span class="line">hset person age 20</span><br><span class="line">hset person id 1</span><br><span class="line">hget person name</span><br><span class="line">person &#x3D; &#123;</span><br><span class="line">    &quot;name&quot;: &quot;bingo&quot;,</span><br><span class="line">    &quot;age&quot;: 20,</span><br><span class="line">    &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h5><p>list 是有序列表</p><p><strong>比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</strong></p><p><strong>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。</span><br><span class="line">lrange mylist 0 -1</span><br></pre></td></tr></table></figure><p>比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist 1</span><br><span class="line">lpush mylist 2</span><br><span class="line">lpush mylist 3 4 5</span><br><span class="line"></span><br><span class="line"># 1</span><br><span class="line">rpop mylist</span><br></pre></td></tr></table></figure><h5 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h5><p>set 是无序集合，自动去重。</p><p>直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 redis 进行全局的 set 去重。</p><p><strong>可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？</strong></p><p>把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#-------操作一个set-------</span><br><span class="line"># 添加元素</span><br><span class="line">sadd mySet 1</span><br><span class="line"></span><br><span class="line"># 查看全部元素</span><br><span class="line">smembers mySet</span><br><span class="line"></span><br><span class="line"># 判断是否包含某个值</span><br><span class="line">sismember mySet 3</span><br><span class="line"></span><br><span class="line"># 删除某个&#x2F;些元素</span><br><span class="line">srem mySet 1</span><br><span class="line">srem mySet 2 4</span><br><span class="line"></span><br><span class="line"># 查看元素个数</span><br><span class="line">scard mySet</span><br><span class="line"></span><br><span class="line"># 随机删除一个元素</span><br><span class="line">spop mySet</span><br><span class="line"></span><br><span class="line">#-------操作多个set-------</span><br><span class="line"># 将一个set的元素移动到另外一个set</span><br><span class="line">smove yourSet mySet 2</span><br><span class="line"></span><br><span class="line"># 求两set的交集</span><br><span class="line">sinter yourSet mySet</span><br><span class="line"></span><br><span class="line"># 求两set的并集</span><br><span class="line">sunion yourSet mySet</span><br><span class="line"></span><br><span class="line"># 求在yourSet中而不在mySet中的元素</span><br><span class="line">sdiff yourSet mySet</span><br></pre></td></tr></table></figure><h5 id="sorted-set"><a class="markdownIt-Anchor" href="#sorted-set"></a> sorted set</h5><p>sorted set 是排序的 set，<strong>去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zadd board 85 zhangsan</span><br><span class="line">zadd board 72 lisi</span><br><span class="line">zadd board 96 wangwu</span><br><span class="line">zadd board 63 zhaoliu</span><br><span class="line"></span><br><span class="line"># 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）</span><br><span class="line">zrevrange board 0 3</span><br><span class="line"></span><br><span class="line"># 获取某用户的排名</span><br><span class="line">zrank board zhaoliu</span><br></pre></td></tr></table></figure></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/" title="阅读redis设计与实现笔记" target="_blank" rel="external">https://duanjiaojiao316.github.io/2020/02/23/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/duanjiaojiao316" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/duanjiaojiao316" target="_blank"><span class="text-dark">熟悉路线站点</span><small class="ml-1x">Developer &amp; Designer</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/02/23/Spring%20%E6%A1%86%E6%9E%B6%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%88IoC%E3%80%81AOP%EF%BC%89/" title="Spring 框架两大核心机制（IoC、AOP）"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2020/02/21/mybatis%E5%9F%BA%E7%A1%80/" title="mybatis基础"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/duanjiaojiao316" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>