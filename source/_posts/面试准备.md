---
translate_title: ''
---


#### start() run() 的区别?为什么不能直接调用start？

#### wait() sleep()

 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 

#### 线程通信方式

##### 1.使用 *volatile* 关键字

##### 2.使用Object类的wait() 和 notify() 方法

##### 3.使用JUC工具类 CountDownLatch

##### 4.使用 ReentrantLock 结合 Condition

##### 5.基本LockSupport实现线程间的阻塞和唤醒

#### 进程通信方式

##### 1.管道

##### 2.共享内存

##### 3.套接字

##### 4.信号量

##### 5.消息队列

#### 线程池？线程池原理，线程池线程数量维护

##### ThreadPoolExecutor构造方法

```java 
	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }


    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }

	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

```java
corePoolSize 核心池的大小
maximumPoolSize 线程池最大线程数
keepAliveTime 表示线程没有任务执行时最多保持多久时间会终止。
unit 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性
workQueue 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：
        ArrayBlockingQueue;
        LinkedBlockingQueue;
        SynchronousQueue;
        ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。
            
threadFactory：线程工厂，主要用来创建线程；
handler：表示当拒绝处理任务时的策略，有以下四种取值：
    ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
    ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
    ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
    ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
        
```

ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。

　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；

　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；

　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；

　　然后ThreadPoolExecutor继承了类AbstractExecutorService。

##### 2.线程池中线程创建

默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。

　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：

- prestartCoreThread()：初始化一个核心线程；
- prestartAllCoreThreads()：初始化所有核心线程

##### 3.线程数目维护

- 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
- 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中。若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
- 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
- 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

##### 4.任务缓存队列及排队策略

　　任务缓存队列，即workQueue，它用来存放等待执行的任务。

　　workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：

1. 　　ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；
2. 　　LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
3. 　　synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。

##### 5.任务拒绝策略

handler：表示当拒绝处理任务时的策略，有以下四种取值：
    ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
    ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
    ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）丢弃任务队列中比较久的任务
    ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 

##### 6.线程池的关闭

　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

- shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
- shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

##### 7.线程池容量的动态调整

　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，

- setCorePoolSize：设置核心池大小
- setMaximumPoolSize：设置线程池最大能创建的线程数目大小

　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。

#### <font color="red">hashMap</font>

##### 1.为什么capacity是2的指数次幂，初始的capacity是16 而不是8,4

```java
/** * The default initial capacity - MUST be a power of two. */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

使用二进制容量可以更好的计算hash值，可以避免使用取余运算提高效率也保证以下的式子成立。

```java
hash%length == hash & (length - 1)
```

16 - 1= 1111，可以保证put进入的元素的均匀的分布减少碰撞，之所以不选 8 4 ，会造成扩容消耗。 

##### 2.为什么他的loadFactor是0.75？

loadFactor规定太大，比如1会造成严重的hash碰撞

```java 
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

loadFactor规定较小，查询的效率高，节省时间，但是空间会造成浪费。

所以要在空间和时间上进行折中选择

##### 3.hashMap中链表容量到达8的时候转换为红黑树

泊松分布

```java
 (exp(-0.5) * pow(0.5, k)
  
  	 * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
```

5.扩容

```java
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null; //低位链表头部，尾部
                        Node<K,V> hiHead = null, hiTail = null; //高位链表尾部，尾部
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {//oldCap的值16，结果为0
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {                        //oldCap的值16，结果为1
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;//断掉链表的指针
                            newTab[j] = loHead;//放在新的数组相同的索引的位置
                        }
                        if (hiTail != null) {
                            hiTail.next = null;//断掉链表的指针
                            newTab[j + oldCap] = hiHead;//放在新的数组相同索引相对原容量的的位置
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

没有重新hash分成两组。链表长度减小。

扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入

插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）

#### ```HashTable```

- 底层数组+链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个```HashTable```，效率低，```ConcurrentHashMap```做了相关优化
- 初始size为**11**，扩容：```newsize``` = ```oldsize```*2+1
- 计算index的方法：index = (hash & 0x7FFFFFFF) % ```tab.length```

```java
 public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new Entry<?,?>[initialCapacity];
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    }

    /**
     * Constructs a new, empty hashtable with the specified initial capacity
     * and default load factor (0.75).
     *
     * @param     initialCapacity   the initial capacity of the hashtable.
     * @exception IllegalArgumentException if the initial capacity is less
     *              than zero.
     */
    public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }

    /**
     * Constructs a new, empty hashtable with a default initial capacity (11)
     * and load factor (0.75).
     */
    public Hashtable() {
        this(11, 0.75f);
    }
	 /**
     * Constructs a new hashtable with the same mappings as the given
     * Map.  The hashtable is created with an initial capacity sufficient to
     * hold the mappings in the given Map and a default load factor (0.75).
     *
     * @param t the map whose mappings are to be placed in this map.
     * @throws NullPointerException if the specified map is null.
     * @since   1.2
     */
    public Hashtable(Map<? extends K, ? extends V> t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
```

##### ```HashTable```通过synchronized实现线程安全

```java
public synchronized boolean containsKey(Object key) {
        Entry<?,?> tab[] = table;
        int hash = key.hashCode();
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
```

#### ```ConcurrentHashMap```　　 

ConcurrentHashMap采用了非常精妙的"分段锁"策略，ConcurrentHashMap的主干是个Segment数组。

```java
 final Segment<K,V>[] segments;
```

　　Segment继承了```ReentrantLock```，所以它就是一种可重入锁。在```ConcurrentHashMap```，一个Segment就是一个子哈希表，Segment里维护了一个```HashEntry```数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的```ConcurrentLevel```为16来讲，理论上就允许16个线程并发执行）

**所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。**

#### static

##### 1.静态代码块

```java
public class A {
    static {
        System.out.println("A static code");
    }
    A(){
        System.out.println("A constructor");
    }
    {
        System.out.println("A normal code");
    }
}

class B extends A{
    static {
        System.out.println("B static code");
    }
    {
        System.out.println("B normal code");
    }
    B(){
        System.out.println("B constructor");
    }
}

public class Main {

    public static void main(String[] args) {
        B b = new B();
        System.out.println();
        B b1 = new B();
    }
}


执行结果：
A static code
B static code
A normal code
A constructor
B normal code
B constructor

A normal code
A constructor
B normal code
B constructor

Process finished with exit code 0
    
```

执行顺序： 静态代码块—>非静态代码块—>构造方法 

静态代码块和非静态代码块都在类加载的时候执行，静态代码块只执行一次，非静态代码块每创建一个对象都会执行一次，最后在进行类实例的创建的时候才执行构造方法。构造方法在最后执行，与其位置无关。

##### 2.静态常量

无需对象就可以访问，但是又不希望外界修改，所以定义为常量

```java
Math.PI
    public static final double PI = 3.1415296……
System.out
    public static final PrintStream out = ...
```

##### 3.静态方法

main方法，在调用的时候没有任何对象产生，所以main无需对象调用为static标记。

#### 继承

##### 1.向上转型

```java
 Person s = new Student(15,"djj",96);
```

但是用过s引用不能查找子类中的变量实现等。

如果子类覆写父类的一个方法，s调用这个方法，实现是student的实现。

```java
public class Person {
    protected int age;
    protected String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
    public void print(){
        System.out.println("the Person");
    }
}

class Student extends Person{
    protected int score;

    public Student(int age, String name, int score) {
        super(age, name);
        this.score = score;
    }
    public void print(){
        System.out.println("the Student");
    }
}

public class Main {
    public static void main(String[] args) {
        Person s = new Student(15,"djj",96);
        s.print();
    }
}


执行结果：
    the Student
```

##### 2.向下转型

向下转型可能会失败，抛出 ```ClassCastException ```异常。

##### 3.区分继承和组合

is关系采用继承，但是has关系使用组合

```java
class Student extends Person{
    protected Book book;
    protected int score;
}
```

#### 多态

 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。 

 利用多态，`totalTax()`方法只需要和`Income`打交道，它完全不需要知道`Salary`和`StateCouncilSpecialAllowance`的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从`Income`派生，然后正确覆写`getTax()`方法就可以。把新的类型传入`totalTax()`，不需要修改任何代码。 

```java
public class Income {
    protected double income;
    //计算税
    public double getTax() {
        return income * 0.1;
    }
}
//工资
class Salary extends Income {
    @Override
    public double getTax() {
        if (income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}
//国家津贴
class StateCouncilSpecialAllowance extends Income {
    @Override
    public double getTax() {
        return 0;
    }
}
public class Main {
    public static void main(String[] args) {
        Income income = new Income();
        income.income = 1000;
        Salary salary = new Salary();
        salary.income = 6000;
        StateCouncilSpecialAllowance state = new StateCouncilSpecialAllowance();
        state.income = 5000;
        System.out.println(totalTax(salary, state));
        System.out.println(totalTax(state));
        System.out.println(totalTax(salary));
        System.out.println(totalTax(income, salary));
    }
    public static double totalTax(Income... incomes) {
        double total = 0;
        for (Income income: incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class A
{
    void foo(){}
}
class B：public A
{
    void foo(){}
}
A *pa = new B();
pa->foo();

执行结果：
200.0
0.0
200.0
300.0
```

#### 覆写Object方法

- `toString()`：把instance输出为`String`；
- `equals()`：判断两个instance是否逻辑相等；
- `hashCode()`：计算一个instance的哈希值。

 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用 。

 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override` 。`final`修饰符有多种作用：

#### final

- `final`修饰的方法可以阻止被覆写；
- `final`修饰的class可以阻止被继承；
- `final`修饰的field必须在创建对象时初始化，随后不可修改。

#### 抽象类和接口

##### default方法

|            | abstract class       | interface                   |
| :--------- | :------------------- | :-------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

实现类可以不必覆写`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

`default`方法和抽象类的普通方法是有所不同的。因为`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段。

#####  interface字段

因为`interface`是一个纯抽象类，所以它不能定义实例字段。但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型： 

```java
public interface Person {
    public static final int MALE = 1;
    public static final int FEMALE = 2;
}

//因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：
public interface Person {
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
}
```

#### 作用域

##### package包作用域

最后，包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。

`public`、`protected`、`private`略

##### 局部变量

在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。

#### 异常和错误

Error和RuntimeException是非受查异常，其他的异常为受查异常。

在程序中无须将非受查异常进行catch或者throws。

在测试阶段可以使用断言来进行。

##### 常见的RuntimeException异常

NullPointerException - 空指针引用异常
ClassCastException - 类型强制转换异常。
IllegalArgumentException - 传递非法参数异常。
ArithmeticException - 算术运算异常
ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
IndexOutOfBoundsException - 下标越界异常

##### 常见的CheckedException异常

SQLException
OException
ClassNotFoundException
NamingException,
ServletException,

#### 反射

##### 获取class实例的方式

1. 直接通过一个`class`的静态变量`class`获取：

   ```java
   Class cls = String.class;
   ```

2. 如果我们有一个实例变量，可以通过该实例变量提供的`getClass()`方法获取：

   ```java
   String s = "Hello";
   Class cls = s.getClass();
   ```

3. 如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：

   ```java
   Class cls = Class.forName("java.lang.String");
   ```

因为`Class`实例在JVM中是唯一的。所以获取的String实例是相同的

```java
Class a = String.class;
Class b = "Hello".getClass();
a == b; //true
```

##### == 和instanceof的区别

 用`instanceof`不但匹配当前类型，还匹配当前类型的子类。而用`==`判断`class`实例可以精确地判断数据类型，但不能作子类型比较。 也就是如果该类是子类```instanceof```也返回true，但是==返回false

```java
Integer n = new Integer(123);

boolean b3 = n instanceof Integer; // true
boolean b4 = n instanceof Number; // true

boolean b1 = n.getClass() == Integer.class; // true
boolean b2 = n.getClass() == Number.class; // false
```

 注意到数组（例如`String[]`）也是一种`Class`，而且不同于`String.class`，它的类名是`[Ljava.lang.String`。此外，JVM为每一种基本类型如int也创建了`Class`，通过`int.class`访问。 

 获取到了一个`Class`实例，我们就可以通过该`Class`实例来创建对应类型的实例。

##### JVM动态加载

JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。

##### 访问字段

通过`Class`实例获取字段信息。`Class`类提供了以下几个方法来获取字段：

- Field getField(name)：根据字段名获取某个public的field（包括父类）
- Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
- Field[] getFields()：获取所有public的field（包括父类）
- Field[] getDeclaredFields()：获取当前类的所有field（不包括父类

一个`Field`对象包含了一个字段的所有信息：

- `getName()`：返回字段名称，例如，`"name"`；
- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；
- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。

 先获取`Class`实例，再获取`Field`实例，然后，用`Field.get(Object)`获取指定实例的指定字段的值。 

 通过`Field.set(Object, Object)`实现修改字段的值，其中第一个`Object`参数是指定的实例，第二个`Object`参数是待修改的值。 

```java
    public static void main(String[] args) throws Exception {
        Student s = new Student(15,"djj",96);
        Student s1 = new Student(16,"why",97);
        Class cls = s.getClass();
        Field f = cls.getDeclaredField("score");
        System.out.println(f.get(s)); //96
        System.out.println(f.get(s1)); //97
        f.set(s, 56);
        System.out.println(s.getScore());//56
    }
```

##### 调用方法

通过`Class`实例获取所有`Method`信息。`Class`类提供了以下几个方法来获取`Method`：

- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）
- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）
- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）



一个`Method`对象包含一个方法的所有信息：

- `getName()`：返回方法名称，例如：`"getScore"`；
- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；
- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；
- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。调用非public方法

###### 调用静态方法

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 获取Integer.parseInt(String)方法，参数为String:
        Method m = Integer.class.getMethod("parseInt", String.class);
        // 调用该静态方法并获取结果:
        Integer n = (Integer) m.invoke(null, "12345");
        // 打印调用结果:
        System.out.println(n);
    }
}

int *a;

a = new int[45];

delete a;
```



###### 调用非静态方法

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // String对象:
        String s = "Hello world";
        // 获取String substring(int)方法，参数为int:
        Method m = String.class.getMethod("substring", int.class);
        // 在s对象上调用该方法并获取结果:
        String r = (String) m.invoke(s, 6);
        // 打印调用结果:
        System.out.println(r);
    }
}
```

###### 调用非public方法

和Field类似，对于非public方法，我们虽然可以通过`Class.getDeclaredMethod()`获取该方法实例，但直接对其调用将得到一个`IllegalAccessException`。为了调用非public方法，我们通过`Method.setAccessible(true)`允许其调用：

```java
public class Main {
    public static void main(String[] args) throws Exception {
        Person p = new Person();
        Method m = p.getClass().getDeclaredMethod("setName", String.class);
        m.setAccessible(true);
        m.invoke(p, "Bob");
        System.out.println(p.name);
    }
}
```

##### 构造实例

```java
Person p = Person.class.newInstance();
```

 局限：它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过```Class.newInstance()```来调用。 

 Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例 

通过Class实例获取Constructor的方法如下：

- `getConstructor(Class...)`：获取某个`public`的`Constructor`；
- `getDeclaredConstructor(Class...)`：获取某个`Constructor`；
- `getConstructors()`：获取所有`public`的`Constructor`；
- `getDeclaredConstructors()`：获取所有`Constructor`。

`Constructor`总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。

调用非`public`的`Constructor`时，必须首先通过`setAccessible(true)`设置允许访问。`setAccessible(true)`可能会失败。

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 获取构造方法Integer(int):
        Constructor cons1 = Integer.class.getConstructor(int.class);
        // 调用构造方法:
        Integer n1 = (Integer) cons1.newInstance(123);
        System.out.println(n1);

        // 获取构造方法Integer(String)
        Constructor cons2 = Integer.class.getConstructor(String.class);
        Integer n2 = (Integer) cons2.newInstance("456");
        System.out.println(n2);
    }
}
```

##### 获取父类，实现接口

通过`Class`对象可以获取继承关系：

- `Class getSuperclass()`：获取父类类型；
- `Class[] getInterfaces()`：获取当前类实现的所有接口。

通过`Class`对象的`isAssignableFrom()`方法可以判断一个向上转型是否可以实现。

#### 迭代器

迭代器就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。

##### ```Iterator```接口的实现如下

1. 迭代器在迭代期间可以从集合中移除元素。

　2. 方法名得到了改进，Enumeration的方法名称都比较长。

```java
package java.util;

import java.util.function.Consumer;
public interface Iterator<E> {
    /**
     * Returns {@code true} if the iteration has more elements.
     */
    boolean hasNext();

    /**
     * Returns the next element in the iteration.
     */
    E next();
    
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

##### ```Iterable```

```java
package java.lang;

import java.util.Iterator;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
public interface Iterable<T> {
    //返回一个Iterator对象
    Iterator<T> iterator();
    
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}

```

```Iterable```接口包含一个能产生```Iterator```对象的方法，并且```Iterator```被```foreach```用来在序列中移动。因此如果创建了实现```Iterable```接口的类，都可以将它用于```foreach```中。 

###### 两种遍历方式

使用迭代器遍历和使用```foreach```遍历

```java
		LinkedList<String> linkedList = new LinkedList<>();
        linkedList.push("first");
        linkedList.push("second");
        linkedList.push("third");
        linkedList.push("forth");
        linkedList.push("fifth");
        Iterator<String> linkedListIterable = linkedList.iterator();

        while(linkedListIterable.hasNext()){
            System.out.println(linkedListIterable.next());
        }

        for (String string:linkedList) {
            System.out.println(string);
        }
```

 在使用Iterator的时候禁止对所遍历的容器进行改变其大小结构的操作。例如: 在使用Iterator进行迭代时，如果对集合进行了add、remove操作就会出现```ConcurrentModificationException```异常。 

##### ```ListIterator```

```java
package java.util;

public interface ListIterator<E> extends Iterator<E> {
    
    boolean hasNext();
    
    E next();

    boolean hasPrevious();

    E previous();

    int nextIndex();

    int previousIndex();
    
    void set(E e);

    void add(E e);
}
```

#### AVL

#####  **右旋转的时机**：插入的元素在不平衡节点的左侧的左侧（LL） Y结点不平衡

 ![R](D:\面试\springbootimages\R.webp)

```java
	private Node rightRotate(Node y){
        // 取出y 的左孩子x的右孩子T3
        Node x = y.left;
        Node T3 = x.right;
        x.right = y;
        y.left = T3;

        // 更新height
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        return x;
    }
```

##### 左旋转的时机： **插入的元素在不平衡节点的右侧的右侧（RR）** 

![L](D:\面试\springbootimages\L.webp)

![L1](D:\面试\springbootimages\L1.webp)

```java
    // 对节点y进行向左旋转操作，返回旋转后新的根节点x
    //    y                             x
    //  /  \                          /   \
    // T4   x      向左旋转 (y)      y     z
    //     / \   - - - - - - - ->   / \   / \
    //   T3  z                     T4 T3 T1 T2
    //      / \
    //     T1 T2
    private Node leftRotate(Node y){
        // 取出y 的右孩子x的左孩子T3
        Node x = y.right;
        Node T3 = x.left;
        x.left = y;
        y.right = T3;

        // 更新height
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        return x;
    }
```

##### LR：插入的元素在不平衡节点的左侧的右侧（LR）

![LR](D:\面试\springbootimages\LR.webp)

![LR1](D:\面试\springbootimages\LR1.webp)

##### RL: 插入的元素在不平衡节点的右侧的左侧（RL） 

![RL](D:\面试\springbootimages\RL.webp)

![RL1](D:\面试\springbootimages\RL1.webp)

##### AVL代码实现：

```java
public class AVLTree<K extends Comparable<K>, V>{

    //内部类
    private class Node{
        //当前节点的值
        public K key;
        public V value;
        //左节点
        public Node left;
        //右节点
        public Node right;
        // 节点高度,叶子结点为1
        public int height;

        public Node(K key, V value){
            this.key = key;
            this.value = value;
            left = null;
            right = null;
            height = 1;
        }
    }

    private Node root;//根结点
    private int size;
    
    private int getHeight(Node node){
        if (node == null) return 0;
        return node.height;
   }
    
    // 获取节点node的平衡因子，平衡因子不在[-1,1]区间，说明不是平衡二叉树
 	private int getBalanceFactory(Node node){
        if (node == null) return 0;
        return getHeight(node.left) - getHeight(node.right);
   }
    // 判断该二叉树是否是一颗二分搜索树
    public boolean isBST(){
        // 二分搜索树的一个特性：中序遍历的结果是自然排序的
        ArrayList<K> keys = new ArrayList<>();
        inOrder(root, keys);
        for (int i = 1; i < keys.size(); i++) {
            if (keys.get(i - 1).compareTo(keys.get(i)) > 0)
                return false;
        }
        return true;
    }
    // 判断该二叉树是否是一颗平衡二叉树,看平衡因子
    public boolean isBalanced(){
        return isBalanced(root);
    }

    // 判断node为根的二叉树是否是一颗平衡二叉树，递归算法
    private boolean isBalanced(Node node) {
        if (node == null) return true;
        int balanceFactory = getBalanceFactory(node);
        if (Math.abs(balanceFactory) > 1)
            return false;
    }
    public void add(K key, V value) {
        root = add(root, key, value);
    }

    // 向 node 为根的二分搜索树中添加新的元素（key, value）
    // 返回插入新节点后的二分搜索树的根
    private Node add(Node node, K key, V value) {
        //递归终止条件
        if (node == null) {
            //表示到达最后一个根节点null，则将新节点放入该位置
            size++;
            return new Node(key, value);
        }
        if (key.compareTo(node.key) < 0){
            //递归步骤，往往递归终止条件的参数是和递归步骤的参数对应的
            //将插入新节点后的二分搜索树的根挂在当前树上
            node.left = add(node.left, key, value);
        }else if(key.compareTo(node.key) > 0){
            node.right = add(node.right, key, value);
        }else {
            // 更新value值
            node.value = value;
        }
        // 更新 height,左右孩子中大的height + 1
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
        // 计算平衡因子
        int balanceFactory = getBalanceFactory(node);
        if (Math.abs(balanceFactory) <= 1) return node;
        // 不符合平衡二叉树条件,需要平衡维护
        if (balanceFactory > 1){
            if (getBalanceFactory(node.left) >= 0){
                // 插入的元素在不平衡节点的左侧的左侧（LL）,采用右旋转
                return rightRotate(node);
            }else{
                // 插入的元素在不平衡节点的左侧的右侧（LR）,采用先左旋转再右旋转
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
        }
        if (balanceFactory < -1){
            if (getBalanceFactory(node.right) <= 0){
                // 插入的元素在不平衡节点的右侧的右侧（RR）,采用左旋转
                return leftRotate(node);
            }else {
                // 插入的元素在不平衡节点的右侧的左侧（RL）,采用右旋转再左旋转
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }
        }
        return node;
    }
    
    public V remove(K key) {
        Node node = getNode(root, key);
        if (node != null) {
            root = remove(root, key);
            return node.value;
        }
        return null;
    }

    // 删除以node为根的二分搜索树中的键为key的节点
    // 返回删除节点后的新的二分搜索树
    private Node remove(Node node, K key) {
        // 递归终止条件： 1、走到最后没有找到key ; 2、找到key
        if (node == null) return node;
        Node retNode;
        if (node.key.compareTo(key) == 0){
            if (node.left == null){
                // 待删除的节点左子树为空的情况
                Node rightNode = node.right;
                node.right = null;
                size--;
                retNode = rightNode;
            } else if (node.right == null){
                // 待删除的节点右子树为空的情况
                Node leftNode = node.left;
                node.left = null;
                size--;
                retNode = leftNode;
            }else {
                // 左右子树都不为空,则找出右子树的最小值，即采用e 的后继。然后用这个节点顶替待删除节点的位置
                Node successor = minimum(node.right);
                //由于removeMin 并未对删除元素之后进行平衡检查，所以要么加上，要不不用；
                // 我们这里采用不用，直接使用remove,因为successor就是node.right子树的最小值
//            successor.right = removeMin(node.right);
                successor.right = remove(node.right, successor.key);
                successor.left = node.left;
                node.left = null;
                node.right = null;
                //注意：这里不需要size--，因为removeMin(node.right) 已经操作了size--
                retNode = successor;
            }
        }else if (key.compareTo(node.key) < 0){
            node.left = remove(node.left, key);
            retNode = node;
        }else {
            node.right = remove(node.right, key);
            retNode = node;
        }

        if (retNode == null) return retNode;
        // 更新 height,左右孩子中大的height + 1
        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));
        // 计算平衡因子
        int balanceFactory = getBalanceFactory(retNode);
        // 不符合平衡二叉树条件,需要平衡维护
        if (balanceFactory > 1){
            if (getBalanceFactory(retNode.left) >= 0){
                // 插入的元素在不平衡节点的左侧的左侧（LL）,采用右旋转
                return rightRotate(retNode);
            }else{
                // 插入的元素在不平衡节点的左侧的右侧（LR）,采用先左旋转再右旋转
                retNode.left = leftRotate(retNode.left);
                return rightRotate(retNode);
            }
        }
        if (balanceFactory < -1){
            if (getBalanceFactory(retNode.right) <= 0){
                // 插入的元素在不平衡节点的右侧的右侧（RR）,采用左旋转
                return leftRotate(retNode);
            }else {
                // 插入的元素在不平衡节点的右侧的左侧（RL）,采用右旋转再左旋转
                retNode.right = rightRotate(retNode.right);
                return leftRotate(retNode);
            }
        }
        return retNode;
    }
```

#### 2-3树

##### 添加：

![231](D:\面试\springbootimages\231.jpg)

![232](D:\面试\springbootimages\232.jpg)

![233](D:\面试\springbootimages\233.jpg)

![234](D:\面试\springbootimages\234.jpg)

##### 删除操作：

###### 2-3树有4种节点：

1.仅1个key的叶子节点；

2.有 2个key的叶子节点；

3.仅1个key的非叶子节点；

4.有2个key的非叶子节点。即 1个key与2个key的节点 和 是否为叶子节点 的组合。

###### 删除情况：

  (1）当删除的节点是2个key的叶子节点，则将要删除的目标key删除即可，此时原来待删除的2个key的叶子节点，变成1个key的叶子节点，但是符合2-3树；

![235](D:\面试\springbootimages\235.png)

（2）当删除的节点是2个key的非叶子节点，则此时使用中序遍历找到待删除节点的后继节点，然后将后继节点与待删除节点位置互换，此时就将问题转化为删除节点为叶子节点（平衡树的非叶子节点中序遍历后继节点肯定叶子节点），如果该叶子是2个key，则跟情况（1）一样，如果该节点是只有1个key，则跟后面的情况（4）一样；

![236](D:\面试\springbootimages\236.png)

![237](D:\面试\springbootimages\237.png)

![238](D:\面试\springbootimages\238.png)

（3）当删除的节点是1个key的非叶子节点，实际上操作跟情况（2）是一样的，即使用中序遍历找到待删除节点的后继节点，然后将后继节点与待删除节点位置互换，此时问题转化为删除节点为叶子节点；



（4）当删除的节点是1个key的叶子节点，则将节点删除，此时树肯定不满足2-3树的性质，也即肯定需要调整，但要分情况来进行调整，而总结起来就是当前待删除的1个key的叶子节点，兄弟节点与父节点，分别是1个key还是2个key，即：

a.当父节点是1个key（即此时仅有一个兄弟节点），兄弟节点是2个key，则将兄弟节点的一个key上移成父节点，而父节点下移成子节点，也即跟2个key中插入新节点类似，拆成一父两子，此时树满足2-3树，完成调整。

b.当父节点是1个key，兄弟节点也是1个key，则此时将父节点与兄弟节点合并，将合并后的节点看成当前节点（2key结点），然后重复（4）的判断，即判断合并后的当前节点的兄弟节点与父节点的情况，然后走对应的a.b.c处理，直到满足2-3树，完成调整。

c.当父节点是2个key，即此时有两个兄弟节点，而兄弟节点又可能有多种情况，穷举起来有：删除节点的位置左中右3个，以及另外两个兄弟节点是否为1个key或2个key的4种情况，总共3*4=12种。即，

- i.若删除的是左或右节点，且中间节点只有1个key，则此时父节点的一个key下移，与中间节点合并，此时父节点为1个key，两个子节点，树满足2-3树，完成调整；

-  ii.若删除的是左或右节点，且中间节点有2个key，则此时父节点的一个key下移，中间节点的一个key上移与父节点合并，此时父节点为2个key，3个子节点，树满足2-3树，完成调整；

- iii.若删除的是中间节点，且右节点只有1个key，则此时父节点的一个key下移，与右节点合并，此时父节点为1个key，两个子节点，树满足2-3树，完成调整；

- iv.若删除的是中间节点，且右节点有2个key，则此时父节点的一个key下移，右节点的一个key上移与父节点合并，此时父节点为2个key，3个子节点，树满足2-3树，完成调整。

- 计：i与ii删除左或右节点两种情况，中间节点1个key或2个key两种情况，兄弟节点1个key或2个key两种情况，总共 2x2x2=8 种；删除中间节点一种情况，iii与iv右节点1个key或2个key两种情况，左节点1个或2个key两种情况，总共 1x2x2=4 种； 4+8=12 种全齐，虽然场景有12种，但是处理的方式只有2种，一种是父节点下移与子节点合并，另一种是父节点下移成单独一个子节点，然后2个key的子节点上移一个key与父节点合并。![239](D:\面试\springbootimages\239.png)

![23A](D:\面试\springbootimages\23A.png)

![23B](D:\面试\springbootimages\23B.png)

![23C](D:\面试\springbootimages\23C.png)

![23D](D:\面试\springbootimages\23D.png)

![23F](D:\面试\springbootimages\23F.png)

#### 2-4树

![241](D:\面试\springbootimages\241.png)

##### 添加操作：

（1）如果待插入的节点不是3个key，则直接插入即可；

（2）如果待插入的节点有3个key，则对节点进行分裂，即3个key加上待插入的key，这4个key分裂成1个key跟2个子节点，然后将分裂之后的4个key中的父节点看作向上层插入的key，然后重复（1）、（2）步骤，直到满足2-3-4树的定义性质。

![242](D:\面试\springbootimages\242.png)

![243](D:\面试\springbootimages\243.png)

![244](D:\面试\springbootimages\244.png)

![245](D:\面试\springbootimages\245.png)

##### 删除操作：

（1）当删除的节点是非1个key的叶子节点，则将要删除的目标key删除即可；

（2）当删除的节点是非叶子节点，无论待删除节点的key是多少个，先使用中序遍历找到待删除节点的后继节点，然后将后继节点与待删除节点位置互换，此时就将问题转化为删除节点为叶子节点（平衡树的非叶子节点中序遍历后继节点肯定叶子节点），如果该叶子是非1个key，则跟情况（1）一样，如果该节点是只有1个key，则跟后面的情况（3）一样；

（3）当删除的节点是1个key的叶子节点，则将节点删除，此时树肯定需要调整，即：

a.当父节点是1个key（即此时仅有一个兄弟节点），兄弟节点是非1个key，则将兄弟节点的一个key上移成父节点，而父节点下移成子节点，此时树满足2-3-4树，完成调整。

b.当父节点是1个key，兄弟节点也是1个key，则此时将父节点与兄弟节点合并，将合并后的节点看成当前节点，然后重复（3）的判断，即判断合并后的当前节点的兄弟节点与父节点的情况，然后走对应的a.b.c处理，直到满足2-3-4树，完成调整。

c.当父节点是非1个key，即此时有两个或三个兄弟节点，此时看相邻兄弟节点是否“丰满”，也即是否为3个key，如下，

i.若删除节点的相邻兄弟节点为非3个key，则父节点的一个key下移，与相邻兄弟节点合并，此时树满足2-3树，完成调整；

ii.若删除节点的相邻兄弟节点为3个key，则父节点的一个key下移成1个key的节点，相邻兄弟节点的一个key上移与父节点合并，此时树满足2-3树，完成调整；
![246](D:\面试\springbootimages\246.png)

![247](D:\面试\springbootimages\247.png)

![248](D:\面试\springbootimages\248.png)

#### 红黑树

红黑树也是一种二叉平衡树，它满足如下几个特性（根据算法中的定义）：

1. 根节点是黑色的。
2. 红链接均为左链接。
3. 从任一节点到其可达叶子节点，经过的黑色节点数量一样（黑平衡）。
4. 没有任何一个节点同时与两个红链接相连。

##### 2-3树转换为红黑树

 将3节点的第一个元素，作为第二个元素的左节点，并用红色的线连接，此时红色线连接的节点就相当于红色。 

![red](D:\面试\springbootimages\red.webp)

##### 2-4树转换为红黑树

三节点转换同2-3树转换，四结点的中间key为黑，左右为红分别创建结点。

#### HTTP

##### HTTP协议的演进

Http(HyperText Transfer Protocol)协议是基于TCP的应用层协议，它不关心数据传输的细节，主要用来规定客户端和服务端的数据传输格式，最初是用来向客户端传输HTML页面内容。默认端口是80。

###### 1.HTTP 0.9版本      1991年

这个版本最初用来向客户端传输HTML页面的，所以只有一个GET命令，服务器返回客户端一个HTML页面，不能是其它格式。利用这个版本完全可以构建一个简单的静态网站了。

HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

```html
GET /mypage.html
```

响应也极其简单的：只包含响应文档本身。

```html
<HTML>
这是一个非常简单的HTML页面
</HTML>
```

###### 2.HTTP 1.0版本      1996年

1.0版本改变是比较大的，奠定了现在HTTP协议的基础，这个版本的协议不仅可以传输HTML的文本页面，还可以传输其它二进制文件，例如图片、视频。而且还增加了现在常用的POST和HEAD命令，请求消息和响应消息也不是单一的，规定了一些元数据字段，例如：字符集、编码、状态码等

###### 3.HTTP 1.1版本      1997年

增加了持久连接，就是说之前版本的协议一次请求就是一次TCP连接，请求完成后这个连接就关闭掉了。TCP协议是可靠的，建立连接需要3次握手，断开连接需要4次挥手，并且TCP有流量控制和拥塞控制，有慢开始机制，刚建立连接时传输比较慢，这是比较耗费资源的。一个丰富的页面会有许多图片、表单和超链接。这样的话就会有多次的HTTP请求，所以**在这个版本上默认不关闭TCP连接也不用声明Connection: keep-alive字段**。如果确实要关闭可以指定Connection: close字段。还**引入了管道机制，**就是说在**一个TCP连接里可以同时发送多个HTTP请求**，而不必等待上一个请求响应成功再发送。**还增加了PUT、PATCH、HEAD、 OPTIONS、DELETE等命令**，丰富了客户端和服务端交互动作。还增加了Host字段。

- 连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。
- 增加流水线操作，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
- 支持响应分块。
- 引入额外的缓存控制机制。
-  [`Host`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)头，能够使不同域名配置在同一个IP地址的服务器上 

###### 4.HTTP 2版本      2015年

- HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
- 这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
- 压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
- 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

#### 报文

###### 1.请求报文

HTTP的请求报文结构

|   请求行   | 方法 | URL  | 版本 | CRLF |
| :--------: | :--: | :--: | :--: | :--: |
| **请求头** |  --  |  --  |  --  |  --  |
| **请求体** |  --  |  --  |  --  |  --  |

报文由三部分组成，即**请求行**、**请求头**和**请求体**。其中请求行指定的是方法、URL、协议版本、CRLF(回车和换行）；请求头是键值对形式存在的，类似Accept-Languag:zh-CN;请求体就是要传输的数据。
 举例：

```swift
Accept:text/html,application/xhtml+xml,application/xml;image/webp
Accept-Encoding:gzip,deflate,sdch
Accept-Language:zh-CN
Cache-Control:max-age=0
Connection:keep-alive
Host:xiaojiadian.gome.com.cn
User-Agent:Mozilla/5.0(Windows NT 6.1;WOW64)AppleWebkit/537.36(KHTML,like Gecko)Chrome/49.0.6.423
```

###### 2.响应报文

HTTP的响应报文结构

|   状态行   | 版本 | 状态码 | 解释状态码短语 | CRLF |
| :--------: | :--: | :----: | :------------: | :--: |
| **响应头** |  --  |   --   |       --       |  --  |
| **响应体** |  --  |   --   |       --       |  --  |

报文由三部分组成，即**状态行**、**响应头**和**响应体**。其中状态行指定的是版本、状态码、解释状态码短语、CRLF(回车和换行）；响应头是键值对形式存在的，类似Connection:keep-alive;响应体就是要传输的数据。
 举例：

```css
Connection:keep-alive
Date:Thu,17 Jan 2019 06:36:01 GMT
ETag:B82D6841000
Server:GOMEWS
```

###### Cookie和Session区别

Cookie和Session都是为了保存客户端和服务端的交互状态。Cookie是保存在客户端，Session是保存在服务端；Cookie是客户端请求服务端时服务器会将一些信息以键值对形式返回给客户端，保存在浏览器中。Cookie的缺点是大小和数量都有限制（浏览器标准不一致，建议cookie个数小于20个，总大小小于4KB）;Cookie如果很大，每次请求都要带上，这样就影响了传输效率。Session是基于Cookie来实现的，Session存在于服务端，但是每次传输的时候不会传输数据，只是把代表一个客户端的唯一ID(SessionID)写在客户端。Session优势传输数据量小，比较安全。

#### SSL

##### 过程：

 1、客户端请求建立SSL连接，首先客户端生成一个**随机数**RNc，并将其与**客户端支持的加密算法信息**发送给服务器端；随后，服务器端回复客户端的建立请求，生成一个**随机数**RNs，并将其与**服务器端支持的加密算法信息**回复给客户端。
 2、服务器端向客户端发送服务器**证书（包含着服务器的公钥）**并请求客户端发送其对应的证书。客户端接受到服务器的证书后，会验证服务器证书的合法性。
 3、客户端验证服务器**证书的合法性通过后，客户端会向服务器提交自己的客户端证书**，服务器也会对客户端的证书进行验证。随后客户端会将此前收到的信息进行hash处理，并且用自己的私钥进行加密后发送给服务器端。服务器端收到相应的信息后，会用客户端的公钥解密检查hash和签名。验证通过后，客户端会随机生成一个临时的对称加密密钥PMS，并用服务器的公钥加密后发送给服务器端。最后双方根据此前生成的RNc、RNs和PMS计算得出真正的对称加密密钥MS。
 4、随后双方建立起以对称加密密钥MS为key的安全加密连接开始通信，并且结束SSL的handshake过程。

![img](D:\面试\springbootimages\20141107004428713) 

##### session的恢复

握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。

这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。

session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。

![img](D:\面试\springbootimages\20141107010428027)

上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。

session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID**往往只保留在一台服务器上**。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。

![img](D:\面试\springbootimages\20141107010524484)

上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个**session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了**。